import { __awaiter, __generator } from "tslib";
import { sleep } from "./utils/sleep";
import { WaiterState } from "./waiter";
/**
 * Reference: https://awslabs.github.io/smithy/1.0/spec/waiters.html#waiter-retries
 */
var exponentialBackoffWithJitter = function (minDelay, maxDelay, attemptCeiling, attempt) {
    if (attempt > attemptCeiling)
        return maxDelay;
    var delay = minDelay * Math.pow(2, (attempt - 1));
    return randomInRange(minDelay, delay);
};
var randomInRange = function (min, max) { return min + Math.random() * (max - min); };
/**
 * Function that runs indefinite polling as part of waiters.
 * @param params options passed to the waiter.
 * @param client AWS SDK Client
 * @param input client input
 * @param stateChecker function that checks the acceptor states on each poll.
 */
export var runPolling = function (_a, input, acceptorChecks) {
    var minDelay = _a.minDelay, maxDelay = _a.maxDelay, maxWaitTime = _a.maxWaitTime, abortController = _a.abortController, client = _a.client;
    return __awaiter(void 0, void 0, void 0, function () {
        var currentAttempt, waitUntil, attemptCeiling, delay, state;
        var _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    currentAttempt = 1;
                    waitUntil = Date.now() + maxWaitTime * 1000;
                    attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
                    _c.label = 1;
                case 1:
                    if (!true) return [3 /*break*/, 4];
                    if ((_b = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _b === void 0 ? void 0 : _b.aborted) {
                        return [2 /*return*/, { state: WaiterState.ABORTED }];
                    }
                    delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
                    // Resolve the promise explicitly at timeout or aborted. Otherwise this while loop will keep making API call until
                    // `acceptorCheck` returns non-retry status, even with the Promise.race() outside.
                    if (Date.now() + delay * 1000 > waitUntil) {
                        return [2 /*return*/, { state: WaiterState.TIMEOUT }];
                    }
                    return [4 /*yield*/, sleep(delay)];
                case 2:
                    _c.sent();
                    return [4 /*yield*/, acceptorChecks(client, input)];
                case 3:
                    state = (_c.sent()).state;
                    if (state !== WaiterState.RETRY) {
                        return [2 /*return*/, { state: state }];
                    }
                    currentAttempt += 1;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9sbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3BvbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0QyxPQUFPLEVBQXVDLFdBQVcsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUU1RTs7R0FFRztBQUNILElBQU0sNEJBQTRCLEdBQUcsVUFBQyxRQUFnQixFQUFFLFFBQWdCLEVBQUUsY0FBc0IsRUFBRSxPQUFlO0lBQy9HLElBQUksT0FBTyxHQUFHLGNBQWM7UUFBRSxPQUFPLFFBQVEsQ0FBQztJQUM5QyxJQUFNLEtBQUssR0FBRyxRQUFRLEdBQUcsU0FBQSxDQUFDLEVBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUEsQ0FBQztJQUM1QyxPQUFPLGFBQWEsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDeEMsQ0FBQyxDQUFDO0FBRUYsSUFBTSxhQUFhLEdBQUcsVUFBQyxHQUFXLEVBQUUsR0FBVyxJQUFLLE9BQUEsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsRUFBakMsQ0FBaUMsQ0FBQztBQUV0Rjs7Ozs7O0dBTUc7QUFDSCxNQUFNLENBQUMsSUFBTSxVQUFVLEdBQUcsVUFDeEIsRUFBMkYsRUFDM0YsS0FBWSxFQUNaLGNBQXVFO1FBRnJFLFFBQVEsY0FBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLFdBQVcsaUJBQUEsRUFBRSxlQUFlLHFCQUFBLEVBQUUsTUFBTSxZQUFBOzs7Ozs7O29CQUl0RCxjQUFjLEdBQUcsQ0FBQyxDQUFDO29CQUNqQixTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUM7b0JBRzVDLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7O3lCQUNoRSxJQUFJO29CQUNULFVBQUksZUFBZSxhQUFmLGVBQWUsdUJBQWYsZUFBZSxDQUFFLE1BQU0sMENBQUUsT0FBTyxFQUFFO3dCQUNwQyxzQkFBTyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsT0FBTyxFQUFFLEVBQUM7cUJBQ3ZDO29CQUNLLEtBQUssR0FBRyw0QkFBNEIsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsQ0FBQztvQkFDL0Ysa0hBQWtIO29CQUNsSCxrRkFBa0Y7b0JBQ2xGLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUssR0FBRyxJQUFJLEdBQUcsU0FBUyxFQUFFO3dCQUN6QyxzQkFBTyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsT0FBTyxFQUFFLEVBQUM7cUJBQ3ZDO29CQUNELHFCQUFNLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBQTs7b0JBQWxCLFNBQWtCLENBQUM7b0JBQ0QscUJBQU0sY0FBYyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBQTs7b0JBQTdDLEtBQUssR0FBSyxDQUFBLFNBQW1DLENBQUEsTUFBeEM7b0JBQ2IsSUFBSSxLQUFLLEtBQUssV0FBVyxDQUFDLEtBQUssRUFBRTt3QkFDL0Isc0JBQU8sRUFBRSxLQUFLLE9BQUEsRUFBRSxFQUFDO3FCQUNsQjtvQkFFRCxjQUFjLElBQUksQ0FBQyxDQUFDOzs7Ozs7Q0FFdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNsZWVwIH0gZnJvbSBcIi4vdXRpbHMvc2xlZXBcIjtcbmltcG9ydCB7IFJlc29sdmVkV2FpdGVyT3B0aW9ucywgV2FpdGVyUmVzdWx0LCBXYWl0ZXJTdGF0ZSB9IGZyb20gXCIuL3dhaXRlclwiO1xuXG4vKipcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly9hd3NsYWJzLmdpdGh1Yi5pby9zbWl0aHkvMS4wL3NwZWMvd2FpdGVycy5odG1sI3dhaXRlci1yZXRyaWVzXG4gKi9cbmNvbnN0IGV4cG9uZW50aWFsQmFja29mZldpdGhKaXR0ZXIgPSAobWluRGVsYXk6IG51bWJlciwgbWF4RGVsYXk6IG51bWJlciwgYXR0ZW1wdENlaWxpbmc6IG51bWJlciwgYXR0ZW1wdDogbnVtYmVyKSA9PiB7XG4gIGlmIChhdHRlbXB0ID4gYXR0ZW1wdENlaWxpbmcpIHJldHVybiBtYXhEZWxheTtcbiAgY29uc3QgZGVsYXkgPSBtaW5EZWxheSAqIDIgKiogKGF0dGVtcHQgLSAxKTtcbiAgcmV0dXJuIHJhbmRvbUluUmFuZ2UobWluRGVsYXksIGRlbGF5KTtcbn07XG5cbmNvbnN0IHJhbmRvbUluUmFuZ2UgPSAobWluOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBydW5zIGluZGVmaW5pdGUgcG9sbGluZyBhcyBwYXJ0IG9mIHdhaXRlcnMuXG4gKiBAcGFyYW0gcGFyYW1zIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB3YWl0ZXIuXG4gKiBAcGFyYW0gY2xpZW50IEFXUyBTREsgQ2xpZW50XG4gKiBAcGFyYW0gaW5wdXQgY2xpZW50IGlucHV0XG4gKiBAcGFyYW0gc3RhdGVDaGVja2VyIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIHRoZSBhY2NlcHRvciBzdGF0ZXMgb24gZWFjaCBwb2xsLlxuICovXG5leHBvcnQgY29uc3QgcnVuUG9sbGluZyA9IGFzeW5jIDxDbGllbnQsIElucHV0PihcbiAgeyBtaW5EZWxheSwgbWF4RGVsYXksIG1heFdhaXRUaW1lLCBhYm9ydENvbnRyb2xsZXIsIGNsaWVudCB9OiBSZXNvbHZlZFdhaXRlck9wdGlvbnM8Q2xpZW50PixcbiAgaW5wdXQ6IElucHV0LFxuICBhY2NlcHRvckNoZWNrczogKGNsaWVudDogQ2xpZW50LCBpbnB1dDogSW5wdXQpID0+IFByb21pc2U8V2FpdGVyUmVzdWx0PlxuKTogUHJvbWlzZTxXYWl0ZXJSZXN1bHQ+ID0+IHtcbiAgbGV0IGN1cnJlbnRBdHRlbXB0ID0gMTtcbiAgY29uc3Qgd2FpdFVudGlsID0gRGF0ZS5ub3coKSArIG1heFdhaXRUaW1lICogMTAwMDtcbiAgLy8gVGhlIG1heCBhdHRlbXB0IG51bWJlciB0aGF0IHRoZSBkZXJpdmVkIGRlbGF5IHRpbWUgdGVuZCB0byBpbmNyZWFzZS5cbiAgLy8gUHJlLWNvbXB1dGUgdGhpcyBudW1iZXIgdG8gYXZvaWQgTnVtYmVyIHR5cGUgb3ZlcmZsb3cuXG4gIGNvbnN0IGF0dGVtcHRDZWlsaW5nID0gTWF0aC5sb2cobWF4RGVsYXkgLyBtaW5EZWxheSkgLyBNYXRoLmxvZygyKSArIDE7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlcj8uc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4geyBzdGF0ZTogV2FpdGVyU3RhdGUuQUJPUlRFRCB9O1xuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IGV4cG9uZW50aWFsQmFja29mZldpdGhKaXR0ZXIobWluRGVsYXksIG1heERlbGF5LCBhdHRlbXB0Q2VpbGluZywgY3VycmVudEF0dGVtcHQpO1xuICAgIC8vIFJlc29sdmUgdGhlIHByb21pc2UgZXhwbGljaXRseSBhdCB0aW1lb3V0IG9yIGFib3J0ZWQuIE90aGVyd2lzZSB0aGlzIHdoaWxlIGxvb3Agd2lsbCBrZWVwIG1ha2luZyBBUEkgY2FsbCB1bnRpbFxuICAgIC8vIGBhY2NlcHRvckNoZWNrYCByZXR1cm5zIG5vbi1yZXRyeSBzdGF0dXMsIGV2ZW4gd2l0aCB0aGUgUHJvbWlzZS5yYWNlKCkgb3V0c2lkZS5cbiAgICBpZiAoRGF0ZS5ub3coKSArIGRlbGF5ICogMTAwMCA+IHdhaXRVbnRpbCkge1xuICAgICAgcmV0dXJuIHsgc3RhdGU6IFdhaXRlclN0YXRlLlRJTUVPVVQgfTtcbiAgICB9XG4gICAgYXdhaXQgc2xlZXAoZGVsYXkpO1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGF3YWl0IGFjY2VwdG9yQ2hlY2tzKGNsaWVudCwgaW5wdXQpO1xuICAgIGlmIChzdGF0ZSAhPT0gV2FpdGVyU3RhdGUuUkVUUlkpIHtcbiAgICAgIHJldHVybiB7IHN0YXRlIH07XG4gICAgfVxuXG4gICAgY3VycmVudEF0dGVtcHQgKz0gMTtcbiAgfVxufTtcbiJdfQ==