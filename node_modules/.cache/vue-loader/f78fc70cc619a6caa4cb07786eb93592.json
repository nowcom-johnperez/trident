{"remainingRequest":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/components/ActionMenu.vue?vue&type=style&index=0&id=2f7f7010&lang=scss&scoped=true","dependencies":[{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/components/ActionMenu.vue","mtime":1716430447141},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js","mtime":1716430467357},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1716430467929},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/postcss-loader/src/index.js","mtime":1716430467882},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/sass-loader/dist/cjs.js","mtime":1716430453705},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1716430467929}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci5yb290IHsKICBwb3NpdGlvbjogYWJzb2x1dGU7Cn0KCi5tZW51IHsKICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgdmlzaWJpbGl0eTogaGlkZGVuOwogIHRvcDogMDsKICBsZWZ0OiAwOwogIHotaW5kZXg6IHotaW5kZXgoJ2Ryb3Bkb3duQ29udGVudCcpOwogIG1pbi13aWR0aDogMTQ1cHg7CgogIGNvbG9yOiB2YXIoLS1kcm9wZG93bi10ZXh0KTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kcm9wZG93bi1iZyk7CiAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZHJvcGRvd24tYm9yZGVyKTsKICBib3JkZXItcmFkaXVzOiA1cHg7CiAgYm94LXNoYWRvdzogMCA1cHggMjBweCB2YXIoLS1zaGFkb3cpOwoKICBMSSB7CiAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgZGlzcGxheTogZmxleDsKICAgIHBhZGRpbmc6IDhweCAxMHB4OwogICAgbWFyZ2luOiAwOwoKICAgICZbZGlzYWJsZWRdIHsKICAgICAgY3Vyc29yOiBub3QtYWxsb3dlZCAgIWltcG9ydGFudDsKICAgICAgY29sb3I6IHZhcigtLWRpc2FibGVkLXRleHQpOwogICAgfQoKICAgICYuZGl2aWRlciB7CiAgICAgIHBhZGRpbmc6IDA7CiAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1kcm9wZG93bi1kaXZpZGVyKTsKICAgIH0KCiAgICAmOm5vdCguZGl2aWRlcik6aG92ZXIgewogICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kcm9wZG93bi1ob3Zlci1iZyk7CiAgICAgIGNvbG9yOiB2YXIoLS1kcm9wZG93bi1ob3Zlci10ZXh0KTsKICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgfQoKICAgIC5pY29uIHsKICAgICAgZGlzcGxheTogdW5zZXQ7CiAgICAgIHdpZHRoOiAxNHB4OwogICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICAgIG1hcmdpbi1yaWdodDogOHB4OwogICAgfQoKICAgICYubm8tYWN0aW9ucyB7CiAgICAgIGNvbG9yOiB2YXIoLS1kaXNhYmxlZC10ZXh0KTsKICAgIH0KCiAgICAmLm5vLWFjdGlvbnM6aG92ZXIgewogICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbml0aWFsOwogICAgICBjb2xvcjogdmFyKC0tZGlzYWJsZWQtdGV4dCk7CiAgICAgIGN1cnNvcjogZGVmYXVsdDsKICAgIH0KICB9Cn0KCi5iYWNrZ3JvdW5kIHsKICBwb3NpdGlvbjogZml4ZWQ7CiAgdG9wOiAwOwogIGxlZnQ6IDA7CiAgcmlnaHQ6IDA7CiAgYm90dG9tOiAwOwogIG9wYWNpdHk6IDA7CiAgei1pbmRleDogei1pbmRleCgnZHJvcGRvd25PdmVybGF5Jyk7Cn0K"},{"version":3,"sources":["ActionMenu.vue"],"names":[],"mappings":";AAoWA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ActionMenu.vue","sourceRoot":"node_modules/@rancher/shell/components","sourcesContent":["<script>\nimport { mapGetters } from 'vuex';\nimport { AUTO, CENTER, fitOnScreen } from '@shell/utils/position';\nimport { isAlternate } from '@shell/utils/platform';\nimport IconOrSvg from '@shell/components/IconOrSvg';\n\nconst HIDDEN = 'hide';\nconst CALC = 'calculate';\nconst SHOW = 'show';\n\nexport default {\n  name:       'ActionMenu',\n  components: { IconOrSvg },\n  props:      {\n    customActions: {\n      // Custom actions can be used if you need the action\n      // menu to work for something that is not a Kubernetes\n      // resource, for example, a receiver within an\n      // AlertmanagerConfig.\n\n      // This prop can also be used to avoid\n      // a dependency on Vuex. For now, this component can have\n      // its state controlled by either props OR by Vuex, but if it\n      // gets unwieldy, it could later be split into two components,\n      // one with the dependency on Vuex and one without.\n      type:    Array,\n      default: () => {\n        return [];\n      }\n    },\n    open: {\n      // Use this prop to show and hide the action menu if\n      // you want to avoid an unnecessary dependency on Vuex.\n\n      // Note: There are known issues with performance if this component\n      // is included with every row of a table, so don't do that.\n      // Instead the ActionMenu component can be included once on a page,\n      // and then if you click on a list item, that can change\n      // the menu's target so that it can open in different locations.\n      type:    Boolean,\n      default: false\n    },\n    useCustomTargetElement: {\n      // The custom target element can be a\n      // variable in the component state of a list or detail page\n      // if you don't want a dependency on Vuex.\n      // Then when an action menu button is clicked, it can emit an event\n      // that triggers the target to be set to the clicked element,\n      // so that the dropdown menu can open where the context menu\n      // was clicked.\n      // This flag tells the component to look for and use the\n      // custom target element.\n      type:    Boolean,\n      default: false\n    },\n    customTargetElement: {\n      type:    HTMLElement,\n      default: null\n    },\n    customTargetEvent: {\n      // The event details from the user's click can be used\n      // for positioning the menu on the page.\n      type:    [PointerEvent, MouseEvent],\n      default: null\n    },\n\n    /**\n     * Inherited global identifier prefix for tests\n     * Define a term based on the parent component to avoid conflicts on multiple components\n     */\n    componentTestid: {\n      type:    String,\n      default: 'action-menu'\n    }\n  },\n\n  data() {\n    return { phase: HIDDEN, style: {} };\n  },\n\n  computed: {\n    ...mapGetters({\n      // Use either these Vuex getters\n      // OR the props to set the action menu state,\n      // but don't use both.\n      targetElem:  'action-menu/elem',\n      targetEvent: 'action-menu/event',\n      shouldShow:  'action-menu/showing',\n      options:     'action-menu/options'\n    }),\n\n    showing() {\n      return this.phase !== HIDDEN;\n    },\n    menuOptions() {\n      if (this.customActions.length > 0) {\n        return this.customActions;\n      }\n\n      return this.options;\n    },\n  },\n\n  watch: {\n    shouldShow: {\n      handler(show) {\n        if ( show ) {\n          this.phase = CALC;\n          this.updateStyle();\n          this.$nextTick(() => {\n            if ( this.phase === CALC ) {\n              this.phase = SHOW;\n              this.updateStyle();\n            }\n          });\n        } else {\n          this.phase = HIDDEN;\n        }\n      },\n    },\n\n    open() {\n      // This component has a timing issue where the\n      // mounted size of the expanded menu is used to\n      // calculate where its position should be. That means\n      // it won't work if the style is a computed property,\n      // so we put a watcher here to update the style instead.\n      this.updateStyle();\n    },\n\n    '$route.path'(val, old) {\n      this.hide();\n    }\n  },\n\n  methods: {\n    hide() {\n      if (this.useCustomTargetElement) {\n        // If the show/hide state is controlled\n        // by props, emit an event to close the menu.\n        this.$emit('close');\n      } else {\n        // If the show/hide state is controlled\n        // by Vuex, mutate the store to close the menu.\n        this.$store.commit('action-menu/hide');\n      }\n    },\n\n    updateStyle() {\n      if ( this.phase === SHOW && !this.useCustomTargetElement) {\n        const menu = this.$el?.querySelector && this.$el.querySelector('.menu');\n        const event = this.targetEvent;\n        const elem = this.targetElem;\n\n        // If the action menu state is controlled with Vuex,\n        // use the target element and the target event\n        // to position the menu.\n        this.style = fitOnScreen(menu, elem || event, {\n          overlapX:  true,\n          fudgeX:    elem ? -2 : 0,\n          fudgeY:    elem ? 20 : 0,\n          positionX: (elem ? AUTO : CENTER),\n          positionY: AUTO,\n        });\n        this.style.visibility = 'visible';\n\n        return;\n      }\n\n      if ( this.open && this.useCustomTargetElement) {\n        const menu = this.$el?.querySelector && this.$el.querySelector('.menu');\n        const elem = this.customTargetElement;\n\n        // If the action menu state is controlled with\n        // props, use the target element to position the menu.\n        this.style = fitOnScreen(menu, elem, {\n          overlapX:  true,\n          fudgeX:    elem ? 4 : 0,\n          fudgeY:    elem ? 4 : 0,\n          positionX: (elem ? AUTO : CENTER),\n          positionY: AUTO,\n        }, true );\n\n        this.style.visibility = 'visible';\n\n        return;\n      }\n\n      this.style = {};\n    },\n\n    execute(action, event, args) {\n      if (action.disabled) {\n        return;\n      }\n\n      // this will come from extensions...\n      if (action.invoke) {\n        const fn = action.invoke;\n\n        if (fn && action.enabled) {\n          const resources = this.$store.getters['action-menu/resources'];\n          const opts = {\n            event,\n            action,\n            isAlt: isAlternate(event)\n          };\n\n          if (resources.length === 1) {\n            fn.apply(this, [opts, resources]);\n          }\n        }\n      } else if (this.useCustomTargetElement) {\n        // If the state of this component is controlled\n        // by props instead of Vuex, we assume you wouldn't want\n        // the mutation to have a dependency on Vuex either.\n        // So in that case we use events to execute actions instead.\n        // If an action list item is clicked, this\n        // component emits that event, then we assume the parent\n        // component will execute the action.\n        this.$emit(action.action, {\n          action,\n          event,\n          ...args,\n          route: this.$route\n        });\n      } else {\n        // If the state of this component is controlled\n        // by Vuex, mutate the store when an action is clicked.\n        const opts = { alt: isAlternate(event) };\n\n        this.$store.dispatch('action-menu/execute', {\n          action, args, opts\n        });\n      }\n\n      this.hide();\n    },\n\n    hasOptions(options) {\n      return options.length !== undefined ? options.length : Object.keys(options).length > 0;\n    }\n  },\n};\n</script>\n\n<template>\n  <div v-if=\"showing || open\">\n    <div\n      class=\"background\"\n      @click=\"hide\"\n      @contextmenu.prevent\n    />\n    <ul\n      class=\"list-unstyled menu\"\n      :style=\"style\"\n    >\n      <li\n        v-for=\"(opt, i) in menuOptions\"\n        :key=\"opt.action\"\n        :disabled=\"opt.disabled\"\n        :class=\"{divider: opt.divider}\"\n        :data-testid=\"componentTestid + '-' + i + '-item'\"\n        @click=\"execute(opt, $event)\"\n      >\n        <IconOrSvg\n          v-if=\"opt.icon || opt.svg\"\n          :icon=\"opt.icon\"\n          :src=\"opt.svg\"\n          class=\"icon\"\n          color=\"header\"\n        />\n        <span v-clean-html=\"opt.label\" />\n      </li>\n\n      <li\n        v-if=\"!hasOptions(menuOptions)\"\n        class=\"no-actions\"\n      >\n        <span v-t=\"'sortableTable.noActions'\" />\n      </li>\n    </ul>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n  .root {\n    position: absolute;\n  }\n\n  .menu {\n    position: absolute;\n    visibility: hidden;\n    top: 0;\n    left: 0;\n    z-index: z-index('dropdownContent');\n    min-width: 145px;\n\n    color: var(--dropdown-text);\n    background-color: var(--dropdown-bg);\n    border: 1px solid var(--dropdown-border);\n    border-radius: 5px;\n    box-shadow: 0 5px 20px var(--shadow);\n\n    LI {\n      align-items: center;\n      display: flex;\n      padding: 8px 10px;\n      margin: 0;\n\n      &[disabled] {\n        cursor: not-allowed  !important;\n        color: var(--disabled-text);\n      }\n\n      &.divider {\n        padding: 0;\n        border-bottom: 1px solid var(--dropdown-divider);\n      }\n\n      &:not(.divider):hover {\n        background-color: var(--dropdown-hover-bg);\n        color: var(--dropdown-hover-text);\n        cursor: pointer;\n      }\n\n      .icon {\n        display: unset;\n        width: 14px;\n        text-align: center;\n        margin-right: 8px;\n      }\n\n      &.no-actions {\n        color: var(--disabled-text);\n      }\n\n      &.no-actions:hover {\n        background-color: initial;\n        color: var(--disabled-text);\n        cursor: default;\n      }\n    }\n  }\n\n  .background {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    opacity: 0;\n    z-index: z-index('dropdownOverlay');\n  }\n</style>\n"]}]}