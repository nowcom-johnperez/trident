{"remainingRequest":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/components/nav/WindowManager/ContainerShell.vue?vue&type=style&index=0&id=1bc2ab70&lang=scss","dependencies":[{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/components/nav/WindowManager/ContainerShell.vue","mtime":1716430447141},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js","mtime":1716430467357},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1716430467929},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/postcss-loader/src/index.js","mtime":1716430467882},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/sass-loader/dist/cjs.js","mtime":1716430453705},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1716430467929}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci54dGVybS1jaGFyLW1lYXN1cmUtZWxlbWVudCB7CiAgcG9zaXRpb246IHN0YXRpYzsKfQo="},{"version":3,"sources":["ContainerShell.vue"],"names":[],"mappings":";AA2eA;AACA;AACA","file":"ContainerShell.vue","sourceRoot":"node_modules/@rancher/shell/components/nav/WindowManager","sourcesContent":["<script>\nimport { allHash } from '@shell/utils/promise';\nimport { addParams } from '@shell/utils/url';\nimport { base64Decode, base64Encode } from '@shell/utils/crypto';\nimport Select from '@shell/components/form/Select';\nimport { NODE } from '@shell/config/types';\n\nimport Socket, {\n  EVENT_CONNECTED,\n  EVENT_CONNECTING,\n  EVENT_DISCONNECTED,\n  EVENT_MESSAGE,\n  //  EVENT_FRAME_TIMEOUT,\n  EVENT_CONNECT_ERROR,\n} from '@shell/utils/socket';\nimport Window from './Window';\n\nconst commands = {\n  linux: [\n    '/bin/sh',\n    '-c',\n    'TERM=xterm-256color; export TERM; [ -x /bin/bash ] && ([ -x /usr/bin/script ] && /usr/bin/script -q -c \"/bin/bash\" /dev/null || exec /bin/bash) || exec /bin/sh',\n  ],\n  windows: ['cmd']\n};\n\nexport default {\n  components: { Window, Select },\n\n  props: {\n    // The definition of the tab itself\n    tab: {\n      type:     Object,\n      required: true,\n    },\n\n    // Is this tab currently displayed\n    active: {\n      type:     Boolean,\n      required: true,\n    },\n\n    // The height of the window\n    height: {\n      type:    Number,\n      default: undefined,\n    },\n\n    // The width of the window\n    width: {\n      type:    Number,\n      default: undefined,\n    },\n\n    // The pod to connect to\n    pod: {\n      type:     Object,\n      required: true,\n    },\n\n    // The container in the pod to initially show\n    initialContainer: {\n      type:    String,\n      default: null,\n    },\n\n    // Runs this command immediately after connecting\n    commandOnFirstConnect: {\n      type:    String,\n      default: null\n    }\n  },\n\n  data() {\n    return {\n      container:      this.initialContainer || this.pod?.defaultContainerName,\n      socket:         null,\n      terminal:       null,\n      fitAddon:       null,\n      searchAddon:    null,\n      webglAddon:     null,\n      isOpen:         false,\n      isOpening:      false,\n      backlog:        [],\n      node:           null,\n      keepAliveTimer: null,\n      errorMsg:       '',\n      backupShells:   ['linux', 'windows'],\n      os:             undefined,\n      retries:        0\n    };\n  },\n\n  computed: {\n    xtermConfig() {\n      return {\n        allowProposedApi: true,\n        cursorBlink:      true,\n        useStyle:         true,\n        fontSize:         12,\n      };\n    },\n\n    containerChoices() {\n      return this.pod?.spec?.containers?.map((x) => x.name) || [];\n    },\n  },\n\n  watch: {\n    container() {\n      this.connect();\n    },\n\n    height() {\n      this.fit();\n    },\n\n    width() {\n      this.fit();\n    },\n  },\n\n  beforeDestroy() {\n    clearInterval(this.keepAliveTimer);\n    this.cleanup();\n  },\n\n  async mounted() {\n    const nodeId = this.pod.spec?.nodeName;\n\n    try {\n      const schema = this.$store.getters[`cluster/schemaFor`](NODE);\n\n      if (schema) {\n        await this.$store.dispatch('cluster/find', { type: NODE, id: nodeId });\n      }\n    } catch {}\n\n    await this.setupTerminal();\n    await this.connect();\n\n    clearInterval(this.keepAliveTimer);\n    this.keepAliveTimer = setInterval(() => {\n      this.fit();\n    }, 60 * 1000);\n  },\n\n  methods: {\n    async setupTerminal() {\n      const docStyle = getComputedStyle(document.querySelector('body'));\n      const xterm = await import(/* webpackChunkName: \"xterm\" */ 'xterm');\n\n      const addons = await allHash({\n        fit:      import(/* webpackChunkName: \"xterm\" */ 'xterm-addon-fit'),\n        webgl:    import(/* webpackChunkName: \"xterm\" */ 'xterm-addon-webgl'),\n        weblinks: import(/* webpackChunkName: \"xterm\" */ 'xterm-addon-web-links'),\n        search:   import(/* webpackChunkName: \"xterm\" */ 'xterm-addon-search'),\n      });\n\n      const terminal = new xterm.Terminal({\n        theme: {\n          background:          docStyle.getPropertyValue('--terminal-bg').trim(),\n          foreground:          docStyle.getPropertyValue('--terminal-text').trim(),\n          cursor:              docStyle.getPropertyValue('--terminal-cursor').trim(),\n          selectionBackground: docStyle.getPropertyValue('--terminal-selection').trim(),\n        },\n        ...this.xtermConfig,\n      });\n\n      this.fitAddon = new addons.fit.FitAddon();\n      this.searchAddon = new addons.search.SearchAddon();\n\n      try {\n        this.webglAddon = new addons.webgl.WebGlAddon();\n      } catch (e) {\n        // Some browsers (Safari) don't support the webgl renderer, so don't use it.\n        this.webglAddon = null;\n      }\n\n      terminal.loadAddon(this.fitAddon);\n      terminal.loadAddon(this.searchAddon);\n      terminal.loadAddon(new addons.weblinks.WebLinksAddon());\n      terminal.open(this.$refs.xterm);\n\n      if (this.webglAddon) {\n        terminal.loadAddon(this.webglAddon);\n      }\n\n      this.fit();\n      this.flush();\n\n      terminal.onData((input) => {\n        const msg = `0${ base64Encode(input) }`;\n\n        this.write(msg);\n      });\n\n      this.terminal = terminal;\n    },\n\n    write(msg) {\n      if (this.isOpen) {\n        this.socket.send(msg);\n      } else {\n        this.backlog.push(msg);\n      }\n    },\n\n    clear() {\n      this.terminal.clear();\n    },\n\n    getSocketUrl() {\n      if (!this.pod?.links?.view) {\n        return;\n      }\n\n      if (this.pod.os) {\n        this.os = this.pod.os;\n        this.backupShells = this.backupShells.filter((shell) => shell !== this.pod.os);\n      } else {\n        this.os = this.backupShells.shift();\n      }\n\n      const url = addParams(\n        `${ this.pod.links.view.replace(/^http/, 'ws') }/exec`,\n        {\n          container: this.container,\n          stdout:    1,\n          stdin:     1,\n          stderr:    1,\n          tty:       1,\n          command:   commands[this.os],\n        }\n      );\n\n      return url;\n    },\n\n    async connect() {\n      if (this.socket) {\n        await this.socket.disconnect();\n        this.socket = null;\n        this.terminal.reset();\n      }\n\n      const url = this.getSocketUrl();\n\n      if (!url) {\n        return;\n      }\n\n      this.socket = new Socket(url, false, 0, 'base64.channel.k8s.io');\n\n      this.socket.addEventListener(EVENT_CONNECTING, (e) => {\n        this.isOpen = false;\n        this.isOpening = true;\n        this.errorMsg = '';\n      });\n\n      this.socket.addEventListener(EVENT_CONNECT_ERROR, (e) => {\n        this.isOpen = false;\n        this.isOpening = false;\n        console.error('Connect Error', e); // eslint-disable-line no-console\n      });\n\n      this.socket.addEventListener(EVENT_CONNECTED, (e) => {\n        this.isOpen = true;\n        this.isOpening = false;\n        this.fit();\n        this.flush();\n\n        if (this.commandOnFirstConnect) {\n          this.terminal.paste(`${ this.commandOnFirstConnect }`);\n        }\n      });\n\n      this.socket.addEventListener(EVENT_DISCONNECTED, (e) => {\n        this.isOpen = false;\n        this.isOpening = false;\n\n        // If we had an error message, try connecting with the next command\n        if (this.errorMsg) {\n          this.terminal.write(this.errorMsg);\n          if (this.backupShells.length && this.retries < 2) {\n            this.retries++;\n            // we're not really counting on this being a reactive change so there's no need to fire the whole action\n            this.pod.os = undefined;\n            // the pod will still return an os if one's been defined in the node so we'll skip the backups if that's the case and rely on retry count to break the retry loop\n            if (!this.pod.os) {\n              this.os = undefined;\n            }\n            this.connect();\n          } else {\n            // Output an message to let he user know none of the shell commands worked\n            this.terminal.write(this.t('wm.containerShell.failed'));\n          }\n        }\n      });\n\n      this.socket.addEventListener(EVENT_MESSAGE, (e) => {\n        const type = e.detail.data.substr(0, 1);\n        const msg = base64Decode(e.detail.data.substr(1));\n\n        this.errorMsg = '';\n\n        if (`${ type }` === '1') {\n          if (msg) {\n            // we're not really counting on this being a reactive change so there's no need to fire the whole action\n            this.pod.os = this.os;\n          }\n          this.terminal.write(msg);\n        } else {\n          console.error(msg); // eslint-disable-line no-console\n\n          if (`${ type }` === '3') {\n            this.errorMsg = msg;\n          }\n        }\n      });\n\n      this.socket.connect();\n      this.terminal.focus();\n    },\n\n    flush() {\n      const backlog = this.backlog.slice();\n\n      this.backlog = [];\n\n      for (const data of backlog) {\n        this.socket.send(data);\n      }\n    },\n\n    fit(arg) {\n      if (!this.fitAddon) {\n        return;\n      }\n\n      this.fitAddon.fit();\n\n      const { rows, cols } = this.fitAddon.proposeDimensions() || {};\n\n      if (!this.isOpen) {\n        return;\n      }\n\n      const message = `4${ base64Encode(\n        JSON.stringify({\n          Width:  Math.floor(cols),\n          Height: Math.floor(rows),\n        })\n      ) }`;\n\n      this.socket.send(message);\n    },\n\n    cleanup() {\n      if (this.socket) {\n        this.socket.disconnect();\n        this.socket = null;\n      }\n\n      if (this.terminal) {\n        this.terminal.dispose();\n        this.terminal = null;\n      }\n    },\n  },\n};\n</script>\n\n<template>\n  <Window\n    :active=\"active\"\n    :before-close=\"cleanup\"\n  >\n    <template #title>\n      <Select\n        v-if=\"containerChoices.length > 0\"\n        v-model=\"container\"\n        :disabled=\"containerChoices.length === 1\"\n        class=\"containerPicker auto-width pull-left\"\n        :options=\"containerChoices\"\n        :clearable=\"false\"\n        placement=\"top\"\n      >\n        <template #selected-option=\"option\">\n          <t\n            v-if=\"option\"\n            k=\"wm.containerShell.containerName\"\n            :label=\"option.label\"\n          />\n        </template>\n      </Select>\n      <div class=\"pull-left ml-5\">\n        <button\n          class=\"btn btn-sm bg-primary\"\n          @click=\"clear\"\n        >\n          <t k=\"wm.containerShell.clear\" />\n        </button>\n      </div>\n      <div class=\"status pull-left\">\n        <t\n          v-if=\"isOpen\"\n          k=\"wm.connection.connected\"\n          class=\"text-success\"\n        />\n        <t\n          v-else-if=\"isOpening\"\n          k=\"wm.connection.connecting\"\n          class=\"text-warning\"\n          :raw=\"true\"\n        />\n        <t\n          v-else\n          k=\"wm.connection.disconnected\"\n          class=\"text-error\"\n        />\n      </div>\n    </template>\n    <template #body>\n      <div\n        class=\"shell-container\"\n        :class=\"{ open: isOpen, closed: !isOpen }\"\n      >\n        <div\n          ref=\"xterm\"\n          class=\"shell-body\"\n        />\n        <resize-observer @notify=\"fit\" />\n      </div>\n    </template>\n  </Window>\n</template>\n\n<style lang=\"scss\">\n  .xterm-char-measure-element {\n    position: static;\n  }\n</style>\n\n<style lang=\"scss\" scoped>\n.text-warning {\n  animation: flasher 2.5s linear infinite;\n}\n\n@keyframes flasher {\n  50% {\n    opacity: 0;\n  }\n}\n\n.shell-container {\n  height: 100%;\n  overflow: hidden;\n  .resize-observer {\n    display: none;\n  }\n}\n\n.shell-body {\n  padding: calc(2 * var(--outline-width));\n  height: 100%;\n\n  & > .terminal.focus {\n    outline: var(--outline-width) solid var(--outline);\n  }\n}\n\n.containerPicker {\n  ::v-deep &.unlabeled-select {\n    display: inline-block;\n    min-width: 200px;\n    height: 30px;\n    min-height: 30px;\n    width: initial;\n  }\n}\n\n.status {\n  align-items: center;\n  display: flex;\n  min-width: 80px;\n  height: 30px;\n  margin-left: 10px;\n}\n</style>\n"]}]}