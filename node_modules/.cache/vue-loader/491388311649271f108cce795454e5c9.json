{"remainingRequest":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/list/workload.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/list/workload.vue","mtime":1716430447141},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/babel-loader/lib/index.js","mtime":1716430465839},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1716430467929}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBSZXNvdXJjZVRhYmxlIGZyb20gJ0BzaGVsbC9jb21wb25lbnRzL1Jlc291cmNlVGFibGUnOwppbXBvcnQgewogIFdPUktMT0FEX1RZUEVTLCBTQ0hFTUEsIE5PREUsIFBPRCwgTElTVF9XT1JLTE9BRF9UWVBFUwp9IGZyb20gJ0BzaGVsbC9jb25maWcvdHlwZXMnOwppbXBvcnQgUmVzb3VyY2VGZXRjaCBmcm9tICdAc2hlbGwvbWl4aW5zL3Jlc291cmNlLWZldGNoJzsKCmNvbnN0IHNjaGVtYSA9IHsKICBpZDogICAgICAgICAnd29ya2xvYWQnLAogIHR5cGU6ICAgICAgIFNDSEVNQSwKICBhdHRyaWJ1dGVzOiB7CiAgICBraW5kOiAgICAgICAnV29ya2xvYWQnLAogICAgbmFtZXNwYWNlZDogdHJ1ZQogIH0sCiAgbWV0YWRhdGE6IHsgbmFtZTogJ3dvcmtsb2FkJyB9LAp9OwoKY29uc3QgJGxvYWRpbmdSZXNvdXJjZXMgPSAoJHJvdXRlLCAkc3RvcmUpID0+IHsKICBjb25zdCBhbGxvd2VkUmVzb3VyY2VzID0gW107CgogIE9iamVjdC52YWx1ZXMoTElTVF9XT1JLTE9BRF9UWVBFUykuZm9yRWFjaCgodHlwZSkgPT4gewogICAgLy8gWW91IG1heSBub3QgaGF2ZSBSQkFDIHRvIHNlZSBzb21lIG9mIHRoZSB0eXBlcwogICAgaWYgKCRzdG9yZS5nZXR0ZXJzWydjbHVzdGVyL3NjaGVtYUZvciddKHR5cGUpICkgewogICAgICBhbGxvd2VkUmVzb3VyY2VzLnB1c2godHlwZSk7CiAgICB9CiAgfSk7CgogIGNvbnN0IGFsbFR5cGVzID0gJHJvdXRlLnBhcmFtcy5yZXNvdXJjZSA9PT0gc2NoZW1hLmlkOwoKICByZXR1cm4gewogICAgbG9hZFJlc291cmNlczogICAgIGFsbFR5cGVzID8gYWxsb3dlZFJlc291cmNlcyA6IFskcm91dGUucGFyYW1zLnJlc291cmNlXSwKICAgIGxvYWRJbmRldGVybWluYXRlOiBhbGxUeXBlcywKICB9Owp9OwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICAgICAgICdMaXN0V29ya2xvYWQnLAogIGNvbXBvbmVudHM6IHsgUmVzb3VyY2VUYWJsZSB9LAogIG1peGluczogICAgIFtSZXNvdXJjZUZldGNoXSwKCiAgcHJvcHM6IHsKICAgIHVzZVF1ZXJ5UGFyYW1zRm9yU2ltcGxlRmlsdGVyaW5nOiB7CiAgICAgIHR5cGU6ICAgIEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9CiAgfSwKCiAgYXN5bmMgZmV0Y2goKSB7CiAgICBpZiAodGhpcy5hbGxUeXBlcyAmJiB0aGlzLmxvYWRSZXNvdXJjZXMubGVuZ3RoKSB7CiAgICAgIHRoaXMuJGluaXRpYWxpemVGZXRjaERhdGEodGhpcy5sb2FkUmVzb3VyY2VzWzBdLCB0aGlzLmxvYWRSZXNvdXJjZXMpOwogICAgfSBlbHNlIHsKICAgICAgdGhpcy4kaW5pdGlhbGl6ZUZldGNoRGF0YSh0aGlzLiRyb3V0ZS5wYXJhbXMucmVzb3VyY2UpOwogICAgfQoKICAgIHRyeSB7CiAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuJHN0b3JlLmdldHRlcnNbYGNsdXN0ZXIvc2NoZW1hRm9yYF0oTk9ERSk7CgogICAgICBpZiAoc2NoZW1hKSB7CiAgICAgICAgdGhpcy4kZmV0Y2hUeXBlKE5PREUpOwogICAgICB9CiAgICB9IGNhdGNoIHt9CgogICAgdGhpcy5sb2FkSGVhdGhSZXNvdXJjZXMoKTsKCiAgICBpZiAoIHRoaXMuYWxsVHlwZXMgKSB7CiAgICAgIHRoaXMucmVzb3VyY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5sb2FkUmVzb3VyY2VzLm1hcCgoYWxsb3dlZCkgPT4gewogICAgICAgIHJldHVybiB0aGlzLiRmZXRjaFR5cGUoYWxsb3dlZCwgdGhpcy5sb2FkUmVzb3VyY2VzKTsKICAgICAgfSkpOwogICAgfSBlbHNlIHsKICAgICAgY29uc3QgdHlwZSA9IHRoaXMuJHJvdXRlLnBhcmFtcy5yZXNvdXJjZTsKCiAgICAgIGlmICggdGhpcy4kc3RvcmUuZ2V0dGVyc1snY2x1c3Rlci9zY2hlbWFGb3InXSh0eXBlKSApIHsKICAgICAgICBjb25zdCByZXNvdXJjZSA9IGF3YWl0IHRoaXMuJGZldGNoVHlwZSh0eXBlKTsKCiAgICAgICAgdGhpcy5yZXNvdXJjZXMgPSBbcmVzb3VyY2VdOwogICAgICB9CiAgICB9CiAgfSwKCiAgZGF0YSgpIHsKICAgIC8vIEVuc3VyZSB0aGVzZSBhcmUgc2V0IG9uIGxvYWQgKHRvIGRldGVybWluZSBpZiB0aGUgTlMgZmlsdGVyIGlzIHJlcXVpcmVkKSByYXRoZXIgdGhhbiB0b28gbGF0ZSBvbiBgZmV0Y2hgCiAgICBjb25zdCB7IGxvYWRSZXNvdXJjZXMsIGxvYWRJbmRldGVybWluYXRlIH0gPSAkbG9hZGluZ1Jlc291cmNlcyh0aGlzLiRyb3V0ZSwgdGhpcy4kc3RvcmUpOwoKICAgIHJldHVybiB7CiAgICAgIHJlc291cmNlczogW10sCiAgICAgIGxvYWRSZXNvdXJjZXMsCiAgICAgIGxvYWRJbmRldGVybWluYXRlCiAgICB9OwogIH0sCgogIGNvbXB1dGVkOiB7CiAgICBhbGxUeXBlcygpIHsKICAgICAgcmV0dXJuIHRoaXMuJHJvdXRlLnBhcmFtcy5yZXNvdXJjZSA9PT0gc2NoZW1hLmlkOwogICAgfSwKCiAgICBzY2hlbWEoKSB7CiAgICAgIGNvbnN0IHsgcGFyYW1zOnsgcmVzb3VyY2U6dHlwZSB9IH0gPSB0aGlzLiRyb3V0ZTsKCiAgICAgIGlmICh0eXBlICE9PSBzY2hlbWEuaWQpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1snY2x1c3Rlci9zY2hlbWFGb3InXSh0eXBlKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHNjaGVtYTsKICAgIH0sCgogICAgZmlsdGVyZWRSb3dzKCkgewogICAgICBjb25zdCBvdXQgPSBbXTsKCiAgICAgIGZvciAoIGNvbnN0IHR5cGVSb3dzIG9mIHRoaXMucmVzb3VyY2VzICkgewogICAgICAgIGlmICggIXR5cGVSb3dzICkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQoKICAgICAgICBmb3IgKCBjb25zdCByb3cgb2YgdHlwZVJvd3MgKSB7CiAgICAgICAgICBpZiAoIXRoaXMuYWxsVHlwZXMgfHwgIXJvdy5vd25lZEJ5V29ya2xvYWQpIHsKICAgICAgICAgICAgb3V0LnB1c2gocm93KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBvdXQ7CiAgICB9LAogIH0sCgogIC8vIEFsbCBvZiB0aGUgcmVzb3VyY2VzIHRoYXQgd2Ugd2lsbCBsb2FkIHRoYXQgd2UgbmVlZCBmb3IgdGhlIGxvYWRpbmcgaW5kaWNhdG9yCiAgJGxvYWRpbmdSZXNvdXJjZXMoJHJvdXRlLCAkc3RvcmUpIHsKICAgIHJldHVybiAkbG9hZGluZ1Jlc291cmNlcygkcm91dGUsICRzdG9yZSk7CiAgfSwKCiAgbWV0aG9kczogewogICAgbG9hZEhlYXRoUmVzb3VyY2VzKCkgewogICAgICAvLyBGZXRjaCB0aGVzZSBpbiB0aGUgYmFja2dyb3VuZCB0byBwb3B1bGF0ZSB3b3JrbG9hZCBoZWFsdGgKICAgICAgaWYgKCB0aGlzLmFsbFR5cGVzICkgewogICAgICAgIHRoaXMuJGZldGNoVHlwZShQT0QpOwogICAgICAgIHRoaXMuJGZldGNoVHlwZShXT1JLTE9BRF9UWVBFUy5KT0IpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLiRyb3V0ZS5wYXJhbXMucmVzb3VyY2U7CgogICAgICAgIGlmICh0eXBlID09PSBXT1JLTE9BRF9UWVBFUy5KT0IgfHwgdHlwZSA9PT0gUE9EKSB7CiAgICAgICAgICAvLyBJZ25vcmUgam9iIGFuZCBwb2RzICh3ZSdyZSBmZXRjaGluZyB0aGlzIGFueXdheSwgcGx1cyB0aGV5IGNvbnRhaW4gdGhlaXIgb3duIHN0YXRlKQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgaWYgKHR5cGUgPT09IFdPUktMT0FEX1RZUEVTLkNST05fSk9CKSB7CiAgICAgICAgICB0aGlzLiRmZXRjaFR5cGUoV09SS0xPQURfVFlQRVMuSk9CKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy4kZmV0Y2hUeXBlKFBPRCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfSwKCiAgdHlwZURpc3BsYXkoKSB7CiAgICBjb25zdCB7IHBhcmFtczp7IHJlc291cmNlOnR5cGUgfSB9ID0gdGhpcy4kcm91dGU7CiAgICBsZXQgcGFyYW1TY2hlbWEgPSBzY2hlbWE7CgogICAgaWYgKHR5cGUgIT09IHNjaGVtYS5pZCkgewogICAgICBwYXJhbVNjaGVtYSA9IHRoaXMuJHN0b3JlLmdldHRlcnNbJ2NsdXN0ZXIvc2NoZW1hRm9yJ10odHlwZSk7CiAgICB9CgogICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbJ3R5cGUtbWFwL2xhYmVsRm9yJ10ocGFyYW1TY2hlbWEsIDk5KTsKICB9LAp9Owo="},{"version":3,"sources":["workload.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA","file":"workload.vue","sourceRoot":"node_modules/@rancher/shell/list","sourcesContent":["<script>\nimport ResourceTable from '@shell/components/ResourceTable';\nimport {\n  WORKLOAD_TYPES, SCHEMA, NODE, POD, LIST_WORKLOAD_TYPES\n} from '@shell/config/types';\nimport ResourceFetch from '@shell/mixins/resource-fetch';\n\nconst schema = {\n  id:         'workload',\n  type:       SCHEMA,\n  attributes: {\n    kind:       'Workload',\n    namespaced: true\n  },\n  metadata: { name: 'workload' },\n};\n\nconst $loadingResources = ($route, $store) => {\n  const allowedResources = [];\n\n  Object.values(LIST_WORKLOAD_TYPES).forEach((type) => {\n    // You may not have RBAC to see some of the types\n    if ($store.getters['cluster/schemaFor'](type) ) {\n      allowedResources.push(type);\n    }\n  });\n\n  const allTypes = $route.params.resource === schema.id;\n\n  return {\n    loadResources:     allTypes ? allowedResources : [$route.params.resource],\n    loadIndeterminate: allTypes,\n  };\n};\n\nexport default {\n  name:       'ListWorkload',\n  components: { ResourceTable },\n  mixins:     [ResourceFetch],\n\n  props: {\n    useQueryParamsForSimpleFiltering: {\n      type:    Boolean,\n      default: false\n    }\n  },\n\n  async fetch() {\n    if (this.allTypes && this.loadResources.length) {\n      this.$initializeFetchData(this.loadResources[0], this.loadResources);\n    } else {\n      this.$initializeFetchData(this.$route.params.resource);\n    }\n\n    try {\n      const schema = this.$store.getters[`cluster/schemaFor`](NODE);\n\n      if (schema) {\n        this.$fetchType(NODE);\n      }\n    } catch {}\n\n    this.loadHeathResources();\n\n    if ( this.allTypes ) {\n      this.resources = await Promise.all(this.loadResources.map((allowed) => {\n        return this.$fetchType(allowed, this.loadResources);\n      }));\n    } else {\n      const type = this.$route.params.resource;\n\n      if ( this.$store.getters['cluster/schemaFor'](type) ) {\n        const resource = await this.$fetchType(type);\n\n        this.resources = [resource];\n      }\n    }\n  },\n\n  data() {\n    // Ensure these are set on load (to determine if the NS filter is required) rather than too late on `fetch`\n    const { loadResources, loadIndeterminate } = $loadingResources(this.$route, this.$store);\n\n    return {\n      resources: [],\n      loadResources,\n      loadIndeterminate\n    };\n  },\n\n  computed: {\n    allTypes() {\n      return this.$route.params.resource === schema.id;\n    },\n\n    schema() {\n      const { params:{ resource:type } } = this.$route;\n\n      if (type !== schema.id) {\n        return this.$store.getters['cluster/schemaFor'](type);\n      }\n\n      return schema;\n    },\n\n    filteredRows() {\n      const out = [];\n\n      for ( const typeRows of this.resources ) {\n        if ( !typeRows ) {\n          continue;\n        }\n\n        for ( const row of typeRows ) {\n          if (!this.allTypes || !row.ownedByWorkload) {\n            out.push(row);\n          }\n        }\n      }\n\n      return out;\n    },\n  },\n\n  // All of the resources that we will load that we need for the loading indicator\n  $loadingResources($route, $store) {\n    return $loadingResources($route, $store);\n  },\n\n  methods: {\n    loadHeathResources() {\n      // Fetch these in the background to populate workload health\n      if ( this.allTypes ) {\n        this.$fetchType(POD);\n        this.$fetchType(WORKLOAD_TYPES.JOB);\n      } else {\n        const type = this.$route.params.resource;\n\n        if (type === WORKLOAD_TYPES.JOB || type === POD) {\n          // Ignore job and pods (we're fetching this anyway, plus they contain their own state)\n          return;\n        }\n\n        if (type === WORKLOAD_TYPES.CRON_JOB) {\n          this.$fetchType(WORKLOAD_TYPES.JOB);\n        } else {\n          this.$fetchType(POD);\n        }\n      }\n    }\n  },\n\n  typeDisplay() {\n    const { params:{ resource:type } } = this.$route;\n    let paramSchema = schema;\n\n    if (type !== schema.id) {\n      paramSchema = this.$store.getters['cluster/schemaFor'](type);\n    }\n\n    return this.$store.getters['type-map/labelFor'](paramSchema, 99);\n  },\n};\n</script>\n\n<template>\n  <ResourceTable\n    :loading=\"$fetchState.pending\"\n    :schema=\"schema\"\n    :rows=\"filteredRows\"\n    :overflow-y=\"true\"\n    :use-query-params-for-simple-filtering=\"useQueryParamsForSimpleFiltering\"\n    :force-update-live-and-delayed=\"forceUpdateLiveAndDelayed\"\n  />\n</template>\n"]}]}