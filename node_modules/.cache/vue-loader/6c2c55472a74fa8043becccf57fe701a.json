{"remainingRequest":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/components/Questions/index.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/components/Questions/index.vue","mtime":1716430447141},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/babel-loader/lib/index.js","mtime":1716430465839},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1716430467929}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBKZXhsIGZyb20gJ2pleGwnOwppbXBvcnQgVGFiIGZyb20gJ0BzaGVsbC9jb21wb25lbnRzL1RhYmJlZC9UYWInOwppbXBvcnQgeyBnZXQsIHNldCB9IGZyb20gJ0BzaGVsbC91dGlscy9vYmplY3QnOwppbXBvcnQgeyBzb3J0QnksIGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaCc7CmltcG9ydCB7IF9FRElUIH0gZnJvbSAnQHNoZWxsL2NvbmZpZy9xdWVyeS1wYXJhbXMnOwppbXBvcnQgU3RyaW5nVHlwZSBmcm9tICcuL1N0cmluZyc7CmltcG9ydCBCb29sZWFuVHlwZSBmcm9tICcuL0Jvb2xlYW4nOwppbXBvcnQgRW51bVR5cGUgZnJvbSAnLi9FbnVtJzsKaW1wb3J0IEludFR5cGUgZnJvbSAnLi9JbnQnOwppbXBvcnQgRmxvYXRUeXBlIGZyb20gJy4vRmxvYXQnOwppbXBvcnQgQXJyYXlUeXBlIGZyb20gJy4vQXJyYXknOwppbXBvcnQgTWFwVHlwZSBmcm9tICcuL1F1ZXN0aW9uTWFwJzsKaW1wb3J0IFJlZmVyZW5jZVR5cGUgZnJvbSAnLi9SZWZlcmVuY2UnOwppbXBvcnQgQ2xvdWRDcmVkZW50aWFsVHlwZSBmcm9tICcuL0Nsb3VkQ3JlZGVudGlhbCc7CmltcG9ydCBSYWRpb1R5cGUgZnJvbSAnLi9SYWRpbyc7CmltcG9ydCBZYW1sVHlwZSBmcm9tICcuL1lhbWwnOwoKZXhwb3J0IGNvbnN0IGtub3duVHlwZXMgPSB7CiAgc3RyaW5nOiAgICAgICAgICBTdHJpbmdUeXBlLAogIGhvc3RuYW1lOiAgICAgICAgU3RyaW5nVHlwZSwKICBtdWx0aWxpbmU6ICAgICAgIFN0cmluZ1R5cGUsCiAgcGFzc3dvcmQ6ICAgICAgICBTdHJpbmdUeXBlLAogIGlwYWRkcjogICAgICAgICAgU3RyaW5nVHlwZSwKICBjaWRyOiAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgY3JvbjogICAgICAgICAgICBTdHJpbmdUeXBlLAogIGJvb2xlYW46ICAgICAgICAgQm9vbGVhblR5cGUsCiAgZW51bTogICAgICAgICAgICBFbnVtVHlwZSwKICBpbnQ6ICAgICAgICAgICAgIEludFR5cGUsCiAgZmxvYXQ6ICAgICAgICAgICBGbG9hdFR5cGUsCiAgcXVlc3Rpb25NYXA6ICAgICBNYXBUeXBlLAogIHJlZmVyZW5jZTogICAgICAgUmVmZXJlbmNlVHlwZSwKICBjb25maWdtYXA6ICAgICAgIFJlZmVyZW5jZVR5cGUsCiAgc2VjcmV0OiAgICAgICAgICBSZWZlcmVuY2VUeXBlLAogIHN0b3JhZ2VjbGFzczogICAgUmVmZXJlbmNlVHlwZSwKICBwdmM6ICAgICAgICAgICAgIFJlZmVyZW5jZVR5cGUsCiAgY2xvdWRjcmVkZW50aWFsOiBDbG91ZENyZWRlbnRpYWxUeXBlLAogIHJhZGlvOiAgICAgICAgICAgUmFkaW9UeXBlLAogIHlhbWw6ICAgICAgICAgICAgWWFtbFR5cGUsCn07CgpleHBvcnQgZnVuY3Rpb24gY29tcG9uZW50Rm9yUXVlc3Rpb24ocSkgewogIGNvbnN0IHR5cGUgPSAocS50eXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpOwoKICBpZiAoIGtub3duVHlwZXNbdHlwZV0gKSB7CiAgICByZXR1cm4gdHlwZTsKICB9IGVsc2UgaWYgKCB0eXBlLnN0YXJ0c1dpdGgoJ2FycmF5WycpICkgeyAvLyBUaGlzIG9ubHkgcmVhbGx5IHdvcmtzIGZvciBhcnJheVtzdHJpbmd8bXVsdGlsaW5lXSwgYnV0IGNsb3NlIGVub3VnaCBmb3Igbm93LgogICAgcmV0dXJuIEFycmF5VHlwZTsKICB9IGVsc2UgaWYgKCB0eXBlLnN0YXJ0c1dpdGgoJ21hcFsnKSApIHsgLy8gU2FtZSwgb25seSB3b3JrcyB3aXRoIG1hcFtzdHJpbmd8bXVsdGlsaW5lXQogICAgcmV0dXJuIE1hcFR5cGU7CiAgfSBlbHNlIGlmICggdHlwZS5zdGFydHNXaXRoKCdyZWZlcmVuY2VbJykgKSB7IC8vIFNhbWUsIG9ubHkgd29ya3Mgd2l0aCBtYXBbc3RyaW5nfG11bHRpbGluZV0KICAgIHJldHVybiBSZWZlcmVuY2VUeXBlOwogIH0KCiAgcmV0dXJuICdzdHJpbmcnOwp9CgpleHBvcnQgZnVuY3Rpb24gc2NoZW1hVG9RdWVzdGlvbnMoZmllbGRzKSB7CiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7CiAgY29uc3Qgb3V0ID0gW107CgogIGZvciAoIGNvbnN0IGsgb2Yga2V5cyApIHsKICAgIG91dC5wdXNoKHsKICAgICAgdmFyaWFibGU6IGssCiAgICAgIGxhYmVsOiAgICBrLAogICAgICAuLi5maWVsZHNba10sCiAgICB9KTsKICB9CgogIHJldHVybiBvdXQ7Cn0KCmZ1bmN0aW9uIG1pZ3JhdGUoZXhwcikgewogIGxldCBvdXQ7CgogIGlmICggZXhwci5pbmNsdWRlcygnfHwnKSApIHsKICAgIG91dCA9IGV4cHIuc3BsaXQoJ3x8JykubWFwKCh4KSA9PiBtaWdyYXRlKHgpKS5qb2luKCcgfHwgJyk7CiAgfSBlbHNlIGlmICggZXhwci5pbmNsdWRlcygnJiYnKSApIHsKICAgIG91dCA9IGV4cHIuc3BsaXQoJyYmJykubWFwKCh4KSA9PiBtaWdyYXRlKHgpKS5qb2luKCcgJiYgJyk7CiAgfSBlbHNlIHsKICAgIGNvbnN0IHBhcnRzID0gZXhwci5tYXRjaCgvXiguKikoIT89KSguKikkLyk7CgogICAgaWYgKCBwYXJ0cyApIHsKICAgICAgY29uc3Qga2V5ID0gcGFydHNbMV0udHJpbSgpOwogICAgICBjb25zdCBvcCA9IHBhcnRzWzJdLnRyaW0oKSA9PT0gJyE9JyA/ICchPScgOiAnPT0nOwogICAgICBjb25zdCB2YWwgPSBwYXJ0c1szXS50cmltKCk7CgogICAgICBpZiAoIHZhbCA9PT0gJ3RydWUnIHx8IHZhbCA9PT0gJ2ZhbHNlJyB8fCB2YWwgPT09ICdudWxsJyApIHsKICAgICAgICBvdXQgPSBgJHsga2V5IH0gJHsgb3AgfSAkeyB2YWwgfWA7CiAgICAgIH0gZWxzZSBpZiAoIHZhbCA9PT0gJycgKSB7CiAgICAgICAgLy8gRXhpc3RpbmcgY2hhcnRzIGV4cGVjdCBgZm9vPWAgd2l0aCBge2ZvbzogbnVsbH1gIHRvIGJlIHRydWUuCiAgICAgICAgaWYgKCBvcCA9PT0gJyE9JyApIHsKICAgICAgICAgIG91dCA9IGAhISR7IGtleSB9YDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgb3V0ID0gYCEkeyBrZXkgfWA7CiAgICAgICAgfQogICAgICAgIC8vIG91dCA9IGAkeyBvcCA9PT0gJyEnID8gJyEnIDogJycgfSgkeyBrZXkgfSA9PSAiIiB8fCAkeyBrZXkgfSA9PSBudWxsKWA7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgb3V0ID0gYCR7IGtleSB9ICR7IG9wIH0gIiR7IHZhbCB9ImA7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIHRyeSB7CiAgICAgICAgSmV4bC5jb21waWxlKGV4cHIpOwoKICAgICAgICBvdXQgPSBleHByOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWlncmF0aW5nIGV4cHJlc3Npb246JywgZXhwcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQoKICAgICAgICBvdXQgPSAndHJ1ZSc7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBvdXQ7Cn0KCmV4cG9ydCBkZWZhdWx0IHsKICBjb21wb25lbnRzOiB7IFRhYiwgLi4ua25vd25UeXBlcyB9LAoKICBwcm9wczogewogICAgbW9kZTogewogICAgICB0eXBlOiAgICBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6IF9FRElULAogICAgfSwKCiAgICB2YWx1ZTogewogICAgICB0eXBlOiAgICAgT2JqZWN0LAogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgIH0sCgogICAgdGFiYmVkOiB7CiAgICAgIHR5cGU6ICAgIFtCb29sZWFuLCBTdHJpbmddLAogICAgICBkZWZhdWx0OiB0cnVlLAogICAgfSwKCiAgICAvLyBDYW4gYmUgYSBjaGFydFZlcnNpb24sIHJlc291cmNlIFNjaGVtYSwgb3IgYW4gQXJyYXkgb2YgcXVlc3Rpb24gb2JqZWN0cwogICAgc291cmNlOiB7CiAgICAgIHR5cGU6ICAgICBbT2JqZWN0LCBBcnJheV0sCiAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgfSwKCiAgICB0YXJnZXROYW1lc3BhY2U6IHsKICAgICAgdHlwZTogICAgIFN0cmluZywKICAgICAgcmVxdWlyZWQ6IHRydWUKICAgIH0sCgogICAgaWdub3JlVmFyaWFibGVzOiB7CiAgICAgIHR5cGU6ICAgIEFycmF5LAogICAgICBkZWZhdWx0OiAoKSA9PiBbXSwKICAgIH0sCgogICAgZGlzYWJsZWQ6IHsKICAgICAgdHlwZTogICAgQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UsCiAgICB9LAoKICAgIGluU3RvcmU6IHsKICAgICAgdHlwZTogICAgU3RyaW5nLAogICAgICBkZWZhdWx0OiAnY2x1c3RlcicKICAgIH0sCgogICAgZW1pdDogewogICAgICB0eXBlOiAgICBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZSwKICAgIH0KICB9LAoKICBkYXRhKCkgewogICAgcmV0dXJuIHsgdmFsdWVHZW5lcmF0aW9uOiAwIH07CiAgfSwKCiAgY29tcHV0ZWQ6IHsKICAgIGFsbFF1ZXN0aW9ucygpIHsKICAgICAgaWYgKCB0aGlzLnNvdXJjZS5xdWVzdGlvbnM/LnF1ZXN0aW9ucyApIHsKICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UucXVlc3Rpb25zLnF1ZXN0aW9uczsKICAgICAgfSBlbHNlIGlmICggdGhpcy5zb3VyY2UudHlwZSA9PT0gJ3NjaGVtYScgJiYgdGhpcy5zb3VyY2UucmVzb3VyY2VGaWVsZHMgKSB7CiAgICAgICAgcmV0dXJuIHNjaGVtYVRvUXVlc3Rpb25zKHRoaXMuc291cmNlLnJlc291cmNlRmllbGRzKTsKICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0JyApIHsKICAgICAgICByZXR1cm4gc2NoZW1hVG9RdWVzdGlvbnModGhpcy5zb3VyY2UpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgfSwKCiAgICBzaG93blF1ZXN0aW9ucygpIHsKICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZTsKICAgICAgY29uc3Qgdm0gPSB0aGlzOwoKICAgICAgaWYgKCB0aGlzLnZhbHVlR2VuZXJhdGlvbiA8IDAgKSB7CiAgICAgICAgLy8gUG9pbnRsZXNzIGNvbmRpdGlvbiB0byBnZXQgdGhpcyB0byBkZXBlbmQgb24gZ2VuZXJhdGlvbiBhbmQgcmVjb21wdXRlCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCBvdXQgPSBbXTsKCiAgICAgIGZvciAoIGNvbnN0IHEgb2YgdGhpcy5hbGxRdWVzdGlvbnMgKSB7CiAgICAgICAgaWYgKCB0aGlzLmlnbm9yZVZhcmlhYmxlcy5pbmNsdWRlcyhxLnZhcmlhYmxlKSApIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KCiAgICAgICAgYWRkUXVlc3Rpb24ocSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBvdXQ7CgogICAgICBmdW5jdGlvbiBhZGRRdWVzdGlvbihxLCBkZXB0aCA9IDEsIHBhcmVudEdyb3VwKSB7CiAgICAgICAgaWYgKCAhdm0uc2hvdWxkU2hvdyhxLCB2YWx1ZXMpICkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgcS5kZXB0aCA9IGRlcHRoOwogICAgICAgIHEuZ3JvdXAgPSBxLmdyb3VwIHx8IHBhcmVudEdyb3VwOwoKICAgICAgICBvdXQucHVzaChxKTsKCiAgICAgICAgaWYgKCBxLnN1YnF1ZXN0aW9ucz8ubGVuZ3RoICYmIHZtLnNob3VsZFNob3dTdWIocSwgdmFsdWVzKSApIHsKICAgICAgICAgIGZvciAoIGNvbnN0IHN1YiBvZiBxLnN1YnF1ZXN0aW9ucyApIHsKICAgICAgICAgICAgYWRkUXVlc3Rpb24oc3ViLCBkZXB0aCArIDEsIHEuZ3JvdXApOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICBjaGFydE5hbWUoKSB7CiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jaGFydD8ubmFtZTsKICAgIH0sCgogICAgZ3JvdXBzKCkgewogICAgICBjb25zdCBtYXAgPSB7fTsKICAgICAgY29uc3QgZGVmYXVsdEdyb3VwID0gJ1F1ZXN0aW9ucyc7CiAgICAgIGxldCB3ZWlnaHQgPSB0aGlzLnNob3duUXVlc3Rpb25zLmxlbmd0aDsKCiAgICAgIGZvciAoIGNvbnN0IHEgb2YgdGhpcy5zaG93blF1ZXN0aW9ucyApIHsKICAgICAgICBjb25zdCBncm91cCA9IHEuZ3JvdXAgfHwgZGVmYXVsdEdyb3VwOwoKICAgICAgICBjb25zdCBub3JtYWxpemVkID0gZ3JvdXAudHJpbSgpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuJHN0b3JlLmdldHRlcnNbJ2kxOG4vd2l0aEZhbGxiYWNrJ10oYGNoYXJ0cy4keyB0aGlzLmNoYXJ0TmFtZSB9Lmdyb3VwLiR7IGNhbWVsQ2FzZShncm91cCkgfWAsIG51bGwsIGdyb3VwKTsKCiAgICAgICAgaWYgKCAhbWFwW25vcm1hbGl6ZWRdICkgewogICAgICAgICAgbWFwW25vcm1hbGl6ZWRdID0gewogICAgICAgICAgICBuYW1lLAogICAgICAgICAgICBxdWVzdGlvbnM6IFtdLAogICAgICAgICAgICB3ZWlnaHQ6ICAgIHdlaWdodC0tLAogICAgICAgICAgfTsKICAgICAgICB9CgogICAgICAgIG1hcFtub3JtYWxpemVkXS5xdWVzdGlvbnMucHVzaChxKTsKICAgICAgfQoKICAgICAgY29uc3Qgb3V0ID0gT2JqZWN0LnZhbHVlcyhtYXApOwoKICAgICAgcmV0dXJuIHNvcnRCeShvdXQsICd3ZWlnaHQ6ZGVzYycpOwogICAgfSwKCiAgICBhc1RhYnMoKSB7CiAgICAgIGlmICggdGhpcy50YWJiZWQgPT09IGZhbHNlIHx8IHRoaXMudGFiYmVkID09PSAnbmV2ZXInICkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgaWYgKCB0aGlzLnRhYmJlZCA9PT0gJ211bHRpcGxlJyApIHsKICAgICAgICByZXR1cm4gdGhpcy5ncm91cHMubGVuZ3RoID4gMTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9LAogIH0sCgogIHdhdGNoOiB7CiAgICB2YWx1ZTogewogICAgICBkZWVwOiB0cnVlLAoKICAgICAgaGFuZGxlcigpIHsKICAgICAgICB0aGlzLnZhbHVlR2VuZXJhdGlvbisrOwogICAgICB9LAogICAgfQogIH0sCgogIG1ldGhvZHM6IHsKICAgIGdldCwKICAgIHNldCwKICAgIGNvbXBvbmVudEZvclF1ZXN0aW9uLAoKICAgIHVwZGF0ZSh2YXJpYWJsZSwgJGV2ZW50KSB7CiAgICAgIHNldCh0aGlzLnZhbHVlLCB2YXJpYWJsZSwgJGV2ZW50KTsKICAgICAgaWYgKHRoaXMuZW1pdCkgewogICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZWQnKTsKICAgICAgfQogICAgfSwKICAgIGV2YWxFeHByKGV4cHIsIHZhbHVlcywgcXVlc3Rpb24sIGFsbFF1ZXN0aW9ucykgewogICAgICB0cnkgewogICAgICAgIGNvbnN0IG91dCA9IEpleGwuZXZhbFN5bmMoZXhwciwgdmFsdWVzKTsKCiAgICAgICAgLy8gY29uc29sZS5sb2coJ0V2YWwnLCBleHByLCAnPT4gJywgb3V0KTsKCiAgICAgICAgLy8gSWYgdGhlIHZhcmlhYmxlIGNvbnRhaW5zIGEgaHlwaGVuLCBjaGVjayBpZiBpdCBldmFsdWF0ZXMgdG8gdHJ1ZQogICAgICAgIC8vIGFjY29yZGluZyB0byB0aGUgZXZhbHVhdGlvbiBsb2dpYyB1c2VkIGluIHRoZSBvbGQgVUkuCiAgICAgICAgLy8gVGhpcyBoZWxwcyB1c2VycyBhdm9pZCBtYW51YWwgd29yayB0byBtaWdyYXRlIGZyb20gbGVnYWN5IGFwcHMuCiAgICAgICAgaWYgKCFvdXQgJiYgZXhwci5pbmNsdWRlcygnLScpKSB7CiAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLmV2YWx1YXRlKHF1ZXN0aW9uLCBhbGxRdWVzdGlvbnMpOwoKICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gb3V0OwogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBldmFsdWF0aW5nIGV4cHJlc3Npb246JywgZXhwciwgdmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlCgogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICB9LAogICAgZXZhbHVhdGUocXVlc3Rpb24sIGFsbFF1ZXN0aW9ucykgewogICAgICBpZiAoICFxdWVzdGlvbi5zaG93X2lmICkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGNvbnN0IGFuZCA9IHF1ZXN0aW9uLnNob3dfaWYuc3BsaXQoJyYmJyk7CiAgICAgIGNvbnN0IG9yID0gcXVlc3Rpb24uc2hvd19pZi5zcGxpdCgnfHwnKTsKCiAgICAgIGxldCByZXN1bHQ7CgogICAgICBpZiAoIGdldChvciwgJ2xlbmd0aCcpID4gMSApIHsKICAgICAgICByZXN1bHQgPSBvci5zb21lKChzaG93SWYpID0+IHRoaXMuY2FsRXhwcmVzc2lvbihzaG93SWYsIGFsbFF1ZXN0aW9ucykpOwogICAgICB9IGVsc2UgewogICAgICAgIHJlc3VsdCA9IGFuZC5ldmVyeSgoc2hvd0lmKSA9PiB0aGlzLmNhbEV4cHJlc3Npb24oc2hvd0lmLCBhbGxRdWVzdGlvbnMpKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0sCiAgICBjYWxFeHByZXNzaW9uKHNob3dJZiwgYWxsUXVlc3Rpb25zKSB7CiAgICAgIGlmICggc2hvd0lmLmluY2x1ZGVzKCchPScpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaXNOb3RFcXVhbChzaG93SWYsIGFsbFF1ZXN0aW9ucyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaXNFcXVhbChzaG93SWYsIGFsbFF1ZXN0aW9ucyk7CiAgICAgIH0KICAgIH0sCiAgICBpc0VxdWFsKHNob3dJZiwgYWxsUXVlc3Rpb25zKSB7CiAgICAgIHNob3dJZiA9IHNob3dJZi50cmltKCk7CiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKHNob3dJZiwgJz0nKTsKCiAgICAgIGlmICggdmFyaWFibGVzICkgewogICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLnN0cmluZ2lmeUFuc3dlcih0aGlzLmdldEFuc3dlcih2YXJpYWJsZXMubGVmdCwgYWxsUXVlc3Rpb25zKSk7CiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnN0cmluZ2lmeUFuc3dlcih2YXJpYWJsZXMucmlnaHQpOwoKICAgICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0sCiAgICBpc05vdEVxdWFsKHNob3dJZiwgYWxsUXVlc3Rpb25zKSB7CiAgICAgIHNob3dJZiA9IHNob3dJZi50cmltKCk7CiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKHNob3dJZiwgJyE9Jyk7CgogICAgICBpZiAoIHZhcmlhYmxlcyApIHsKICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5zdHJpbmdpZnlBbnN3ZXIodGhpcy5nZXRBbnN3ZXIodmFyaWFibGVzLmxlZnQsIGFsbFF1ZXN0aW9ucykpOwogICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5zdHJpbmdpZnlBbnN3ZXIodmFyaWFibGVzLnJpZ2h0KTsKCiAgICAgICAgcmV0dXJuIGxlZnQgIT09IHJpZ2h0OwogICAgICB9CgogICAgICByZXR1cm4gZmFsc2U7CiAgICB9LAogICAgZ2V0VmFyaWFibGVzKHNob3dJZiwgb3BlcmF0b3IpIHsKICAgICAgaWYgKCBzaG93SWYuaW5jbHVkZXMob3BlcmF0b3IpKSB7CiAgICAgICAgY29uc3QgYXJyYXkgPSBzaG93SWYuc3BsaXQob3BlcmF0b3IpOwoKICAgICAgICBpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMiApIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGxlZnQ6ICBhcnJheVswXSwKICAgICAgICAgICAgcmlnaHQ6IGFycmF5WzFdCiAgICAgICAgICB9OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfSwKICAgIGdldEFuc3dlcih2YXJpYWJsZSwgcXVlc3Rpb25zKSB7CiAgICAgIGNvbnN0IGZvdW5kID0gcXVlc3Rpb25zLmZpbmQoKHEpID0+IHEudmFyaWFibGUgPT09IHZhcmlhYmxlKTsKCiAgICAgIGlmICggZm91bmQgKSB7CiAgICAgICAgLy8gRXF1aXZhbGVudCB0byBmaW5kaW5nIHF1ZXN0aW9uLmFuc3dlciBpbiBFbWJlcgogICAgICAgIHJldHVybiBnZXQodGhpcy52YWx1ZSwgZm91bmQudmFyaWFibGUpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB2YXJpYWJsZTsKICAgICAgfQogICAgfSwKICAgIHN0cmluZ2lmeUFuc3dlcihhbnN3ZXIpIHsKICAgICAgaWYgKCBhbnN3ZXIgPT09IHVuZGVmaW5lZCB8fCBhbnN3ZXIgPT09IG51bGwgKSB7CiAgICAgICAgcmV0dXJuICcnOwogICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgYW5zd2VyID09PSAnc3RyaW5nJyApIHsKICAgICAgICByZXR1cm4gYW5zd2VyOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBgJHsgYW5zd2VyIH1gOwogICAgICB9CiAgICB9LAogICAgc2hvdWxkU2hvdyhxLCB2YWx1ZXMpIHsKICAgICAgbGV0IGV4cHIgPSBxLmlmOwoKICAgICAgaWYgKCBleHByID09PSB1bmRlZmluZWQgJiYgcS5zaG93X2lmICE9PSB1bmRlZmluZWQgKSB7CiAgICAgICAgZXhwciA9IG1pZ3JhdGUocS5zaG93X2lmKTsKICAgICAgfQoKICAgICAgaWYgKCBleHByICkgewogICAgICAgIGNvbnN0IHNob3duID0gISF0aGlzLmV2YWxFeHByKGV4cHIsIHZhbHVlcywgcSwgdGhpcy5hbGxRdWVzdGlvbnMpOwoKICAgICAgICByZXR1cm4gc2hvd247CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfSwKICAgIHNob3VsZFNob3dTdWIocSwgdmFsdWVzKSB7CiAgICAgIC8vIFNpZ2gsIGJvdGggc2luZ3VsYXIgYW5kIHBsdXJhbCBhcmUgdXNlZCBpbiB0aGUgd2lsZC4uLgogICAgICBsZXQgZXhwciA9ICggcS5zdWJxdWVzdGlvbnNfaWYgPT09IHVuZGVmaW5lZCA/IHEuc3VicXVlc3Rpb25faWYgOiBxLnN1YnF1ZXN0aW9uc19pZik7CiAgICAgIGNvbnN0IG9sZCA9ICggcS5zaG93X3N1YnF1ZXN0aW9uc19pZiA9PT0gdW5kZWZpbmVkID8gcS5zaG93X3N1YnF1ZXN0aW9uX2lmIDogcS5zaG93X3N1YnF1ZXN0aW9uc19pZik7CgogICAgICBpZiAoICFleHByICYmIG9sZCAhPT0gdW5kZWZpbmVkICkgewogICAgICAgIGlmICggb2xkID09PSBmYWxzZSB8fCBvbGQgPT09ICdmYWxzZScgKSB7CiAgICAgICAgICBleHByID0gYCEkeyBxLnZhcmlhYmxlIH1gOwogICAgICAgIH0gZWxzZSBpZiAoIG9sZCA9PT0gdHJ1ZSB8fCBvbGQgPT09ICd0cnVlJyApIHsKICAgICAgICAgIGV4cHIgPSBgISEkeyBxLnZhcmlhYmxlIH1gOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBleHByID0gYCR7IHEudmFyaWFibGUgfSA9PSAiJHsgb2xkIH0iYDsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICggZXhwciApIHsKICAgICAgICByZXR1cm4gdGhpcy5ldmFsRXhwcihleHByLCB2YWx1ZXMsIHEsIHRoaXMuYWxsUXVlc3Rpb25zKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgfSwKfTsK"},{"version":3,"sources":["index.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"node_modules/@rancher/shell/components/Questions","sourcesContent":["<script>\nimport Jexl from 'jexl';\nimport Tab from '@shell/components/Tabbed/Tab';\nimport { get, set } from '@shell/utils/object';\nimport { sortBy, camelCase } from 'lodash';\nimport { _EDIT } from '@shell/config/query-params';\nimport StringType from './String';\nimport BooleanType from './Boolean';\nimport EnumType from './Enum';\nimport IntType from './Int';\nimport FloatType from './Float';\nimport ArrayType from './Array';\nimport MapType from './QuestionMap';\nimport ReferenceType from './Reference';\nimport CloudCredentialType from './CloudCredential';\nimport RadioType from './Radio';\nimport YamlType from './Yaml';\n\nexport const knownTypes = {\n  string:          StringType,\n  hostname:        StringType,\n  multiline:       StringType,\n  password:        StringType,\n  ipaddr:          StringType,\n  cidr:            StringType,\n  cron:            StringType,\n  boolean:         BooleanType,\n  enum:            EnumType,\n  int:             IntType,\n  float:           FloatType,\n  questionMap:     MapType,\n  reference:       ReferenceType,\n  configmap:       ReferenceType,\n  secret:          ReferenceType,\n  storageclass:    ReferenceType,\n  pvc:             ReferenceType,\n  cloudcredential: CloudCredentialType,\n  radio:           RadioType,\n  yaml:            YamlType,\n};\n\nexport function componentForQuestion(q) {\n  const type = (q.type || '').toLowerCase();\n\n  if ( knownTypes[type] ) {\n    return type;\n  } else if ( type.startsWith('array[') ) { // This only really works for array[string|multiline], but close enough for now.\n    return ArrayType;\n  } else if ( type.startsWith('map[') ) { // Same, only works with map[string|multiline]\n    return MapType;\n  } else if ( type.startsWith('reference[') ) { // Same, only works with map[string|multiline]\n    return ReferenceType;\n  }\n\n  return 'string';\n}\n\nexport function schemaToQuestions(fields) {\n  const keys = Object.keys(fields);\n  const out = [];\n\n  for ( const k of keys ) {\n    out.push({\n      variable: k,\n      label:    k,\n      ...fields[k],\n    });\n  }\n\n  return out;\n}\n\nfunction migrate(expr) {\n  let out;\n\n  if ( expr.includes('||') ) {\n    out = expr.split('||').map((x) => migrate(x)).join(' || ');\n  } else if ( expr.includes('&&') ) {\n    out = expr.split('&&').map((x) => migrate(x)).join(' && ');\n  } else {\n    const parts = expr.match(/^(.*)(!?=)(.*)$/);\n\n    if ( parts ) {\n      const key = parts[1].trim();\n      const op = parts[2].trim() === '!=' ? '!=' : '==';\n      const val = parts[3].trim();\n\n      if ( val === 'true' || val === 'false' || val === 'null' ) {\n        out = `${ key } ${ op } ${ val }`;\n      } else if ( val === '' ) {\n        // Existing charts expect `foo=` with `{foo: null}` to be true.\n        if ( op === '!=' ) {\n          out = `!!${ key }`;\n        } else {\n          out = `!${ key }`;\n        }\n        // out = `${ op === '!' ? '!' : '' }(${ key } == \"\" || ${ key } == null)`;\n      } else {\n        out = `${ key } ${ op } \"${ val }\"`;\n      }\n    } else {\n      try {\n        Jexl.compile(expr);\n\n        out = expr;\n      } catch (e) {\n        console.error('Error migrating expression:', expr); // eslint-disable-line no-console\n\n        out = 'true';\n      }\n    }\n  }\n\n  return out;\n}\n\nexport default {\n  components: { Tab, ...knownTypes },\n\n  props: {\n    mode: {\n      type:    String,\n      default: _EDIT,\n    },\n\n    value: {\n      type:     Object,\n      required: true,\n    },\n\n    tabbed: {\n      type:    [Boolean, String],\n      default: true,\n    },\n\n    // Can be a chartVersion, resource Schema, or an Array of question objects\n    source: {\n      type:     [Object, Array],\n      required: true,\n    },\n\n    targetNamespace: {\n      type:     String,\n      required: true\n    },\n\n    ignoreVariables: {\n      type:    Array,\n      default: () => [],\n    },\n\n    disabled: {\n      type:    Boolean,\n      default: false,\n    },\n\n    inStore: {\n      type:    String,\n      default: 'cluster'\n    },\n\n    emit: {\n      type:    Boolean,\n      default: false,\n    }\n  },\n\n  data() {\n    return { valueGeneration: 0 };\n  },\n\n  computed: {\n    allQuestions() {\n      if ( this.source.questions?.questions ) {\n        return this.source.questions.questions;\n      } else if ( this.source.type === 'schema' && this.source.resourceFields ) {\n        return schemaToQuestions(this.source.resourceFields);\n      } else if ( typeof this.source === 'object' ) {\n        return schemaToQuestions(this.source);\n      } else {\n        return [];\n      }\n    },\n\n    shownQuestions() {\n      const values = this.value;\n      const vm = this;\n\n      if ( this.valueGeneration < 0 ) {\n        // Pointless condition to get this to depend on generation and recompute\n        return;\n      }\n\n      const out = [];\n\n      for ( const q of this.allQuestions ) {\n        if ( this.ignoreVariables.includes(q.variable) ) {\n          continue;\n        }\n\n        addQuestion(q);\n      }\n\n      return out;\n\n      function addQuestion(q, depth = 1, parentGroup) {\n        if ( !vm.shouldShow(q, values) ) {\n          return;\n        }\n\n        q.depth = depth;\n        q.group = q.group || parentGroup;\n\n        out.push(q);\n\n        if ( q.subquestions?.length && vm.shouldShowSub(q, values) ) {\n          for ( const sub of q.subquestions ) {\n            addQuestion(sub, depth + 1, q.group);\n          }\n        }\n      }\n    },\n\n    chartName() {\n      return this.source.chart?.name;\n    },\n\n    groups() {\n      const map = {};\n      const defaultGroup = 'Questions';\n      let weight = this.shownQuestions.length;\n\n      for ( const q of this.shownQuestions ) {\n        const group = q.group || defaultGroup;\n\n        const normalized = group.trim().toLowerCase();\n        const name = this.$store.getters['i18n/withFallback'](`charts.${ this.chartName }.group.${ camelCase(group) }`, null, group);\n\n        if ( !map[normalized] ) {\n          map[normalized] = {\n            name,\n            questions: [],\n            weight:    weight--,\n          };\n        }\n\n        map[normalized].questions.push(q);\n      }\n\n      const out = Object.values(map);\n\n      return sortBy(out, 'weight:desc');\n    },\n\n    asTabs() {\n      if ( this.tabbed === false || this.tabbed === 'never' ) {\n        return false;\n      }\n\n      if ( this.tabbed === 'multiple' ) {\n        return this.groups.length > 1;\n      }\n\n      return true;\n    },\n  },\n\n  watch: {\n    value: {\n      deep: true,\n\n      handler() {\n        this.valueGeneration++;\n      },\n    }\n  },\n\n  methods: {\n    get,\n    set,\n    componentForQuestion,\n\n    update(variable, $event) {\n      set(this.value, variable, $event);\n      if (this.emit) {\n        this.$emit('updated');\n      }\n    },\n    evalExpr(expr, values, question, allQuestions) {\n      try {\n        const out = Jexl.evalSync(expr, values);\n\n        // console.log('Eval', expr, '=> ', out);\n\n        // If the variable contains a hyphen, check if it evaluates to true\n        // according to the evaluation logic used in the old UI.\n        // This helps users avoid manual work to migrate from legacy apps.\n        if (!out && expr.includes('-')) {\n          const res = this.evaluate(question, allQuestions);\n\n          return res;\n        }\n\n        return out;\n      } catch (err) {\n        console.error('Error evaluating expression:', expr, values); // eslint-disable-line no-console\n\n        return true;\n      }\n    },\n    evaluate(question, allQuestions) {\n      if ( !question.show_if ) {\n        return true;\n      }\n      const and = question.show_if.split('&&');\n      const or = question.show_if.split('||');\n\n      let result;\n\n      if ( get(or, 'length') > 1 ) {\n        result = or.some((showIf) => this.calExpression(showIf, allQuestions));\n      } else {\n        result = and.every((showIf) => this.calExpression(showIf, allQuestions));\n      }\n\n      return result;\n    },\n    calExpression(showIf, allQuestions) {\n      if ( showIf.includes('!=')) {\n        return this.isNotEqual(showIf, allQuestions);\n      } else {\n        return this.isEqual(showIf, allQuestions);\n      }\n    },\n    isEqual(showIf, allQuestions) {\n      showIf = showIf.trim();\n      const variables = this.getVariables(showIf, '=');\n\n      if ( variables ) {\n        const left = this.stringifyAnswer(this.getAnswer(variables.left, allQuestions));\n        const right = this.stringifyAnswer(variables.right);\n\n        return left === right;\n      }\n\n      return false;\n    },\n    isNotEqual(showIf, allQuestions) {\n      showIf = showIf.trim();\n      const variables = this.getVariables(showIf, '!=');\n\n      if ( variables ) {\n        const left = this.stringifyAnswer(this.getAnswer(variables.left, allQuestions));\n        const right = this.stringifyAnswer(variables.right);\n\n        return left !== right;\n      }\n\n      return false;\n    },\n    getVariables(showIf, operator) {\n      if ( showIf.includes(operator)) {\n        const array = showIf.split(operator);\n\n        if ( array.length === 2 ) {\n          return {\n            left:  array[0],\n            right: array[1]\n          };\n        } else {\n          return null;\n        }\n      }\n\n      return null;\n    },\n    getAnswer(variable, questions) {\n      const found = questions.find((q) => q.variable === variable);\n\n      if ( found ) {\n        // Equivalent to finding question.answer in Ember\n        return get(this.value, found.variable);\n      } else {\n        return variable;\n      }\n    },\n    stringifyAnswer(answer) {\n      if ( answer === undefined || answer === null ) {\n        return '';\n      } else if ( typeof answer === 'string' ) {\n        return answer;\n      } else {\n        return `${ answer }`;\n      }\n    },\n    shouldShow(q, values) {\n      let expr = q.if;\n\n      if ( expr === undefined && q.show_if !== undefined ) {\n        expr = migrate(q.show_if);\n      }\n\n      if ( expr ) {\n        const shown = !!this.evalExpr(expr, values, q, this.allQuestions);\n\n        return shown;\n      }\n\n      return true;\n    },\n    shouldShowSub(q, values) {\n      // Sigh, both singular and plural are used in the wild...\n      let expr = ( q.subquestions_if === undefined ? q.subquestion_if : q.subquestions_if);\n      const old = ( q.show_subquestions_if === undefined ? q.show_subquestion_if : q.show_subquestions_if);\n\n      if ( !expr && old !== undefined ) {\n        if ( old === false || old === 'false' ) {\n          expr = `!${ q.variable }`;\n        } else if ( old === true || old === 'true' ) {\n          expr = `!!${ q.variable }`;\n        } else {\n          expr = `${ q.variable } == \"${ old }\"`;\n        }\n      }\n\n      if ( expr ) {\n        return this.evalExpr(expr, values, q, this.allQuestions);\n      }\n\n      return true;\n    }\n  },\n};\n</script>\n\n<template>\n  <form v-if=\"asTabs\">\n    <Tab\n      v-for=\"g in groups\"\n      :key=\"g.name\"\n      :name=\"g.name\"\n      :label=\"g.name\"\n      :weight=\"g.weight\"\n    >\n      <div\n        v-for=\"q in g.questions\"\n        :key=\"q.variable\"\n        class=\"row question\"\n      >\n        <div class=\"col span-12\">\n          <component\n            :is=\"componentForQuestion(q)\"\n            :in-store=\"inStore\"\n            :question=\"q\"\n            :target-namespace=\"targetNamespace\"\n            :value=\"get(value, q.variable)\"\n            :disabled=\"disabled\"\n            :chart-name=\"chartName\"\n            @input=\"update(q.variable, $event)\"\n          />\n        </div>\n      </div>\n    </Tab>\n  </form>\n  <form v-else>\n    <div\n      v-for=\"g in groups\"\n      :key=\"g.name\"\n    >\n      <h3 v-if=\"groups.length > 1\">\n        {{ g.label }}\n      </h3>\n      <div\n        v-for=\"q in g.questions\"\n        :key=\"q.variable\"\n        class=\"row question\"\n      >\n        <div class=\"col span-12\">\n          <component\n            :is=\"componentForQuestion(q)\"\n            :in-store=\"inStore\"\n            :question=\"q\"\n            :target-namespace=\"targetNamespace\"\n            :mode=\"mode\"\n            :value=\"get(value, q.variable)\"\n            :disabled=\"disabled\"\n            :chart-name=\"chartName\"\n            @input=\"update(q.variable, $event)\"\n          />\n        </div>\n      </div>\n    </div>\n  </form>\n</template>\n\n<style lang=\"scss\" scoped>\n  .question {\n    margin-top: 10px;\n\n    &:first-child {\n      margin-top: 0;\n    }\n  }\n</style>\n"]}]}