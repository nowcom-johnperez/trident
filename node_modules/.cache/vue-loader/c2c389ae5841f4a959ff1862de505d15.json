{"remainingRequest":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/components/form/PodAffinity.vue?vue&type=style&index=0&id=6c79c205&lang=css","dependencies":[{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/components/form/PodAffinity.vue","mtime":1716430447141},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js","mtime":1716430467357},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1716430467929},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/postcss-loader/src/index.js","mtime":1716430467882},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1716430467929}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci5ub2RlLXNlbGVjdG9yewogIHBvc2l0aW9uOiByZWxhdGl2ZTsKfQo="},{"version":3,"sources":["PodAffinity.vue"],"names":[],"mappings":";AA4eA;AACA;AACA","file":"PodAffinity.vue","sourceRoot":"node_modules/@rancher/shell/components/form","sourcesContent":["<script>\nimport { mapGetters } from 'vuex';\nimport { _VIEW } from '@shell/config/query-params';\nimport { get, set, isEmpty, clone } from '@shell/utils/object';\nimport { POD, NODE, NAMESPACE } from '@shell/config/types';\nimport MatchExpressions from '@shell/components/form/MatchExpressions';\nimport LabeledSelect from '@shell/components/form/LabeledSelect';\nimport { RadioGroup } from '@components/Form/Radio';\nimport { LabeledInput } from '@components/Form/LabeledInput';\nimport { randomStr } from '@shell/utils/string';\nimport { sortBy } from '@shell/utils/sort';\nimport debounce from 'lodash/debounce';\nimport ArrayListGrouped from '@shell/components/form/ArrayListGrouped';\nimport { getUniqueLabelKeys } from '@shell/utils/array';\n\nconst NAMESPACE_SELECTION_OPTION_VALUES = {\n  POD:      'pod',\n  ALL:      'all',\n  SELECTED: 'selected',\n};\n\nexport default {\n  components: {\n    ArrayListGrouped, MatchExpressions, LabeledSelect, RadioGroup, LabeledInput\n  },\n\n  props: {\n    // pod template spec\n    value: {\n      type:    Object,\n      default: () => {\n        return {};\n      }\n    },\n\n    // Field key on the value object to store the pod affinity - typically this is 'affinity'\n    // Cluster Agent Configuration uses a different field\n    field: {\n      type:    String,\n      default: 'affinity'\n    },\n\n    mode: {\n      type:    String,\n      default: 'create'\n    },\n\n    nodes: {\n      type:    Array,\n      default: () => []\n    },\n\n    namespaces: {\n      type:    Array,\n      default: null\n    },\n\n    allNamespacesOptionAvailable: {\n      default: false,\n      type:    Boolean\n    },\n\n    forceInputNamespaceSelection: {\n      default: false,\n      type:    Boolean\n    },\n\n    removeLabeledInputNamespaceLabel: {\n      default: false,\n      type:    Boolean\n    },\n\n    overwriteLabels: {\n      type:    Object,\n      default: null\n    },\n\n    loading: {\n      default: false,\n      type:    Boolean\n    },\n  },\n\n  data() {\n    if (!this.value[this.field]) {\n      this.$set(this.value, this.field, {});\n    }\n    const { podAffinity = {}, podAntiAffinity = {} } = this.value[this.field];\n    const allAffinityTerms = [...(podAffinity.preferredDuringSchedulingIgnoredDuringExecution || []), ...(podAffinity.requiredDuringSchedulingIgnoredDuringExecution || [])].map((term) => {\n      let out = clone(term);\n\n      out._id = randomStr(4);\n      out._anti = false;\n      if (term.podAffinityTerm) {\n        Object.assign(out, term.podAffinityTerm);\n        out = this.parsePodAffinityTerm(out);\n\n        delete out.podAffinityTerm;\n      } else {\n        out = this.parsePodAffinityTerm(out);\n      }\n\n      return out;\n    });\n    const allAntiTerms = [...(podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution || []), ...(podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution || [])].map((term) => {\n      let out = clone(term);\n\n      out._id = randomStr(4);\n      out._anti = true;\n      if (term.podAffinityTerm) {\n        Object.assign(out, term.podAffinityTerm);\n        out = this.parsePodAffinityTerm(out);\n\n        delete out.podAffinityTerm;\n      } else {\n        out = this.parsePodAffinityTerm(out);\n      }\n\n      return out;\n    });\n\n    const allSelectorTerms = [...allAffinityTerms, ...allAntiTerms];\n\n    return {\n      allSelectorTerms,\n      defaultWeight:   1,\n      // rules in MatchExpressions.vue can not catch changes what happens on parent component\n      // we need re-render it via key changing\n      rerenderNums:    randomStr(4),\n      NAMESPACE_SELECTION_OPTION_VALUES,\n      defaultAddValue: {\n        _namespaceOption: NAMESPACE_SELECTION_OPTION_VALUES.POD,\n        matchExpressions: [],\n        namespaces:       null,\n        _namespaces:      null,\n      }\n    };\n  },\n  computed: {\n    ...mapGetters({ t: 'i18n/t' }),\n    isView() {\n      return this.mode === _VIEW;\n    },\n\n    pod() {\n      return POD;\n    },\n\n    node() {\n      return NODE;\n    },\n\n    labeledInputNamespaceLabel() {\n      return this.removeLabeledInputNamespaceLabel ? '' : this.overwriteLabels?.namespaceInputLabel || this.t('workload.scheduling.affinity.matchExpressions.inNamespaces');\n    },\n\n    allNamespacesOptions() {\n      const inStore = this.$store.getters['currentStore'](NAMESPACE);\n      const choices = this.namespaces || this.$store.getters[`${ inStore }/all`](NAMESPACE);\n\n      const out = sortBy(choices.map((obj) => {\n        return {\n          label: obj.nameDisplay,\n          value: obj.id,\n        };\n      }), 'label');\n\n      return out;\n    },\n\n    existingNodeLabels() {\n      return getUniqueLabelKeys(this.nodes);\n    },\n\n    hasNodes() {\n      return this.nodes.length;\n    },\n\n    namespaceSelectionOptions() {\n      if (this.allNamespacesOptionAvailable) {\n        return [\n          NAMESPACE_SELECTION_OPTION_VALUES.POD,\n          NAMESPACE_SELECTION_OPTION_VALUES.ALL,\n          NAMESPACE_SELECTION_OPTION_VALUES.SELECTED\n        ];\n      }\n\n      return [\n        NAMESPACE_SELECTION_OPTION_VALUES.POD,\n        NAMESPACE_SELECTION_OPTION_VALUES.SELECTED\n      ];\n    },\n\n    namespaceSelectionLabels() {\n      if (this.overwriteLabels?.namespaceSelectionLabels) {\n        return this.overwriteLabels?.namespaceSelectionLabels;\n      }\n\n      if (this.allNamespacesOptionAvailable) {\n        return [\n          this.t('workload.scheduling.affinity.thisPodNamespace'),\n          this.t('workload.scheduling.affinity.allNamespaces'),\n          this.t('workload.scheduling.affinity.matchExpressions.inNamespaces')\n        ];\n      }\n\n      return [\n        this.t('workload.scheduling.affinity.thisPodNamespace'),\n        this.t('workload.scheduling.affinity.matchExpressions.inNamespaces')\n      ];\n    },\n\n    addLabel() {\n      return this.overwriteLabels?.addLabel || this.t('podAffinity.addLabel');\n    },\n\n    topologyKeyPlaceholder() {\n      return this.overwriteLabels?.topologyKeyPlaceholder || this.t('workload.scheduling.affinity.topologyKey.placeholder');\n    },\n\n    hasNamespaces() {\n      return this.allNamespacesOptions.length;\n    },\n  },\n\n  created() {\n    this.queueUpdate = debounce(this.update, 500);\n  },\n\n  methods: {\n    parsePodAffinityTerm(out) {\n      if (out.namespaceSelector && typeof out.namespaceSelector === 'object' && !Object.keys(out.namespaceSelector).length && this.allNamespacesOptionAvailable) {\n        out._namespaceOption = NAMESPACE_SELECTION_OPTION_VALUES.ALL;\n      } else if (out.namespaces?.length) {\n        out._namespaceOption = NAMESPACE_SELECTION_OPTION_VALUES.SELECTED;\n      } else {\n        out._namespaceOption = NAMESPACE_SELECTION_OPTION_VALUES.POD;\n      }\n\n      out._namespaces = (out.namespaces || []).toString();\n\n      return out;\n    },\n\n    update() {\n      const podAffinity = { requiredDuringSchedulingIgnoredDuringExecution: [], preferredDuringSchedulingIgnoredDuringExecution: [] };\n      const podAntiAffinity = { requiredDuringSchedulingIgnoredDuringExecution: [], preferredDuringSchedulingIgnoredDuringExecution: [] };\n\n      this.allSelectorTerms.forEach((term) => {\n        if (term._anti) {\n          if (term.weight) {\n            const neu = { podAffinityTerm: { ...term }, weight: term.weight || this.defaultWeight };\n\n            delete neu.podAffinityTerm.weight;\n            podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution.push(neu);\n          } else {\n            podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution.push(term);\n          }\n        } else if (term.weight) {\n          const neu = { podAffinityTerm: term, weight: term.weight || this.defaultWeight };\n\n          podAffinity.preferredDuringSchedulingIgnoredDuringExecution.push(neu);\n        } else {\n          podAffinity.requiredDuringSchedulingIgnoredDuringExecution.push(term);\n        }\n      });\n\n      Object.assign(this.value[this.field], { podAffinity, podAntiAffinity });\n      this.$emit('update', this.value);\n    },\n\n    remove() {\n      this.rerenderNums = randomStr(4);\n      this.queueUpdate();\n    },\n\n    changePriority(term, idx) {\n      if (term.weight) {\n        delete term.weight;\n      } else {\n        term.weight = this.defaultWeight;\n      }\n\n      this.$set(this.allSelectorTerms, idx, clone(term));\n      this.queueUpdate();\n    },\n\n    priorityDisplay(term) {\n      return 'weight' in term ? this.t('workload.scheduling.affinity.preferred') : this.t('workload.scheduling.affinity.required');\n    },\n\n    changeNamespaceMode(val, term, idx) {\n      this.$set(term, '_namespaceOption', val);\n\n      switch (val) {\n      case NAMESPACE_SELECTION_OPTION_VALUES.POD:\n        term.namespaces = null;\n        term._namespaces = null;\n\n        if (term.namespaceSelector || term.namespaceSelector === null) {\n          delete term.namespaceSelector;\n        }\n        break;\n      case NAMESPACE_SELECTION_OPTION_VALUES.ALL:\n        term.namespaceSelector = {};\n\n        if (term.namespaces || term.namespaces === null) {\n          delete term.namespaces;\n        }\n\n        if (term._namespaces || term._namespaces === null) {\n          delete term._namespaces;\n        }\n        break;\n\n      default:\n        this.$set(term, 'namespaces', []);\n        this.$set(term, '_namespaces', '');\n\n        if (term.namespaceSelector || term.namespaceSelector === null) {\n          delete term.namespaceSelector;\n        }\n\n        break;\n      }\n\n      this.$set(this.allSelectorTerms, idx, term);\n      this.queueUpdate();\n    },\n\n    updateNamespaces(term, namespaces) {\n      let nsArray = namespaces;\n\n      // namespaces would be String if there is no namespace\n      if (typeof namespaces === 'string') {\n        nsArray = namespaces.split(',').map((ns) => ns.trim()).filter((ns) => ns?.length);\n      }\n\n      this.$set(term, 'namespaces', nsArray);\n      this.queueUpdate();\n    },\n\n    updateLabelSelector(e, props) {\n      this.set(props.row.value, 'labelSelector.matchExpressions', e);\n      this.queueUpdate();\n    },\n\n    isEmpty,\n    get,\n    set\n  }\n\n};\n</script>\n\n<template>\n  <div\n    :style=\"{'width':'100%'}\"\n    class=\"row\"\n    @input=\"queueUpdate\"\n  >\n    <div class=\"col span-12\">\n      <ArrayListGrouped\n        v-model=\"allSelectorTerms\"\n        class=\"mt-20\"\n        :default-add-value=\"defaultAddValue\"\n        :mode=\"mode\"\n        :add-label=\"addLabel\"\n        @remove=\"remove\"\n      >\n        <template #default=\"props\">\n          <div class=\"row mt-20 mb-20\">\n            <div class=\"col span-6\">\n              <LabeledSelect\n                :mode=\"mode\"\n                :options=\"[t('workload.scheduling.affinity.affinityOption'),t('workload.scheduling.affinity.antiAffinityOption')]\"\n                :value=\"props.row.value._anti ?t('workload.scheduling.affinity.antiAffinityOption') :t('workload.scheduling.affinity.affinityOption') \"\n                :label=\"t('workload.scheduling.affinity.type')\"\n                :data-testid=\"`pod-affinity-type-index${props.i}`\"\n                @input=\"$set(props.row.value, '_anti',!props.row.value._anti)\"\n              />\n            </div>\n            <div class=\"col span-6\">\n              <LabeledSelect\n                :key=\"priorityDisplay(props.row.value)\"\n                :mode=\"mode\"\n                :options=\"[t('workload.scheduling.affinity.preferred'),t('workload.scheduling.affinity.required')]\"\n                :value=\"priorityDisplay(props.row.value)\"\n                :label=\"t('workload.scheduling.affinity.priority')\"\n                :data-testid=\"`pod-affinity-priority-index${props.i}`\"\n                @input=\"changePriority(props.row.value, props.i)\"\n              />\n            </div>\n          </div>\n          <div class=\"row\">\n            <RadioGroup\n              :options=\"namespaceSelectionOptions\"\n              :labels=\"namespaceSelectionLabels\"\n              :name=\"`namespaces-${props.row.value._id}`\"\n              :mode=\"mode\"\n              :value=\"props.row.value._namespaceOption\"\n              :data-testid=\"`pod-affinity-namespacetype-index${props.i}`\"\n              @input=\"changeNamespaceMode($event, props.row.value, props.i)\"\n            />\n          </div>\n          <div\n            v-if=\"props.row.value._namespaceOption === NAMESPACE_SELECTION_OPTION_VALUES.SELECTED\"\n            class=\"row mt-10 mb-20\"\n          >\n            <LabeledSelect\n              v-if=\"hasNamespaces && !forceInputNamespaceSelection\"\n              v-model=\"props.row.value.namespaces\"\n              :mode=\"mode\"\n              :multiple=\"true\"\n              :taggable=\"true\"\n              :options=\"allNamespacesOptions\"\n              :label=\"labeledInputNamespaceLabel\"\n              :data-testid=\"`pod-affinity-namespace-select-index${props.i}`\"\n              @input=\"updateNamespaces(props.row.value, props.row.value.namespaces)\"\n            />\n            <LabeledInput\n              v-else\n              v-model=\"props.row.value._namespaces\"\n              :mode=\"mode\"\n              :label=\"labeledInputNamespaceLabel\"\n              :placeholder=\"t('harvesterManager.affinity.namespaces.placeholder')\"\n              :data-testid=\"`pod-affinity-namespace-input-index${props.i}`\"\n              @input=\"updateNamespaces(props.row.value, props.row.value._namespaces)\"\n            />\n          </div>\n          <MatchExpressions\n            :key=\"rerenderNums\"\n            :mode=\"mode\"\n            class=\" col span-12 mt-20\"\n            :type=\"pod\"\n            :value=\"get(props.row.value, 'labelSelector.matchExpressions')\"\n            :show-remove=\"false\"\n            :data-testid=\"`pod-affinity-expressions-index${props.i}`\"\n            @input=\"e=>updateLabelSelector(e, props)\"\n          />\n          <div class=\"row mt-20\">\n            <div class=\"col span-9\">\n              <LabeledSelect\n                v-if=\"hasNodes\"\n                v-model=\"props.row.value.topologyKey\"\n                :taggable=\"true\"\n                :searchable=\"true\"\n                :close-on-select=\"false\"\n                :mode=\"mode\"\n                required\n                :label=\"t('workload.scheduling.affinity.topologyKey.label')\"\n                :placeholder=\"topologyKeyPlaceholder\"\n                :options=\"existingNodeLabels\"\n                :disabled=\"mode==='view'\"\n                :loading=\"loading\"\n                :data-testid=\"`pod-affinity-topology-select-index${props.i}`\"\n                @input=\"update\"\n              />\n              <LabeledInput\n                v-else\n                v-model=\"props.row.value.topologyKey\"\n                :mode=\"mode\"\n                :label=\"t('workload.scheduling.affinity.topologyKey.label')\"\n                :placeholder=\"topologyKeyPlaceholder\"\n                required\n                :data-testid=\"`pod-affinity-topology-input-index${props.i}`\"\n                @input=\"update\"\n              />\n            </div>\n            <div\n              v-if=\"'weight' in props.row.value\"\n              class=\"col span-3\"\n            >\n              <LabeledInput\n                v-model.number=\"props.row.value.weight\"\n                :mode=\"mode\"\n                type=\"number\"\n                min=\"1\"\n                max=\"100\"\n                :label=\"t('workload.scheduling.affinity.weight.label')\"\n                :placeholder=\"t('workload.scheduling.affinity.weight.placeholder')\"\n                :data-testid=\"`pod-affinity-weight-index${props.i}`\"\n              />\n            </div>\n          </div>\n        </template>\n      </ArrayListGrouped>\n    </div>\n  </div>\n</template>\n\n<style>\n.node-selector{\n  position: relative;\n}\n</style>\n"]}]}