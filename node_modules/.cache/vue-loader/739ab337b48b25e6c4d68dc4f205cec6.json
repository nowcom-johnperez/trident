{"remainingRequest":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/pages/rio/mesh.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@rancher/shell/pages/rio/mesh.vue","mtime":1716430447141},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/babel-loader/lib/index.js","mtime":1716430465839},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/cache-loader/dist/cjs.js","mtime":1716430465924},{"path":"/Users/nowcom/Documents/nowcom/trident-extension-package/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1716430467929}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCB7IGVzY2FwZUh0bWwgfSBmcm9tICdAc2hlbGwvdXRpbHMvc3RyaW5nJzsKCmNvbnN0IFJBRElVUyA9IDU7Cgpjb25zdCBJTlRFUlZBTCA9IDEwMDAwOwoKLyoKZnVuY3Rpb24gcmFuZG9tU3RhdHMoKSB7CiAgcmV0dXJuIHsKICAgICdwNTBtcyc6ICAgICAgIE1hdGgucmFuZG9tKCksCiAgICAncDkwbXMnOiAgICAgICBNYXRoLnJhbmRvbSgpICogMiwKICAgICdwOTltcyc6ICAgICAgIE1hdGgucmFuZG9tKCkgKiA1LAogICAgJ3Jwcyc6ICAgICAgICAgTWF0aC5yYW5kb20oKSAqIDEwMCwKICAgICdzdWNjZXNzUmF0ZSc6IE1hdGgucmFuZG9tKCksCiAgfTsKfQoKZnVuY3Rpb24gcmFuZG9tSXRlbShhcnkpIHsKICBjb25zdCBpZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnkubGVuZ3RoKTsKCiAgcmV0dXJuIGFyeVtpZHhdOwp9CgpmdW5jdGlvbiByYW5kb21EYXRhKCkgewogIGNvbnN0IG5vZGVzID0gW107CiAgY29uc3QgZWRnZXMgPSBbXTsKCiAgWydmb28nLCAnYmFyJywgJ2JheicsICdiYXQnLCAncXV4J10uZm9yRWFjaCgobmFtZSkgPT4gewogICAgbm9kZXMucHVzaCh7CiAgICAgICduYW1lc3BhY2UnOiAnZGVmYXVsdCcsCiAgICAgICdhcHAnOiAgICAgICBuYW1lLAogICAgICAndmVyc2lvbic6ICAgJ3YxJywKICAgICAgJ3N0YXRzJzogICAgIHJhbmRvbVN0YXRzKCksCiAgICB9KTsKICB9KTsKCiAgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXS5mb3JFYWNoKChuYW1lKSA9PiB7CiAgICBub2Rlcy5wdXNoKHsKICAgICAgJ25hbWVzcGFjZSc6ICdhbm90aGVyJywKICAgICAgJ2FwcCc6ICAgICAgIG5hbWUsCiAgICAgICd2ZXJzaW9uJzogICAndjEnLAogICAgICAnc3RhdHMnOiAgICAgcmFuZG9tU3RhdHMoKSwKICAgIH0pOwogIH0pOwoKICBmb3IgKCBsZXQgaSA9IDAgOyBpIDwgMTAgOyBpKysgKSB7CiAgICBjb25zdCBmcm9tID0gcmFuZG9tSXRlbShub2Rlcyk7CiAgICBjb25zdCBjcm9zc05zID0gTWF0aC5yYW5kb20oKSA8IDAuMjsKICAgIGNvbnN0IHRvQ2hvaWNlcyA9IG5vZGVzLmZpbHRlcigoeCkgPT4gewogICAgICBpZiAoIHggPT09IGZyb20gKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICBpZiAoIGNyb3NzTnMgKSB7CiAgICAgICAgcmV0dXJuIHgubmFtZXNwYWNlICE9PSBmcm9tLm5hbWVzcGFjZTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4geC5uYW1lc3BhY2UgPT09IGZyb20ubmFtZXNwYWNlOwogICAgICB9CiAgICB9KTsKICAgIGNvbnN0IHRvID0gcmFuZG9tSXRlbSh0b0Nob2ljZXMpOwoKICAgIGVkZ2VzLnB1c2goewogICAgICBmcm9tTmFtZXNwYWNlOiBmcm9tLm5hbWVzcGFjZSwKICAgICAgZnJvbUFwcDogICAgICAgZnJvbS5hcHAsCiAgICAgIGZyb21WZXJzaW9uOiAgIGZyb20udmVyc2lvbiwKICAgICAgdG9OYW1lc3BhY2U6ICAgdG8ubmFtZXNwYWNlLAogICAgICB0b0FwcDogICAgICAgICB0by5hcHAsCiAgICAgIHRvVmVyc2lvbjogICAgIHRvLnZlcnNpb24sCiAgICAgIHN0YXRzOiAgICAgICAgIHJhbmRvbVN0YXRzKCksCiAgICB9KTsKICB9CgogIHJldHVybiB7CiAgICBub2RlcywKICAgIGVkZ2VzCiAgfTsKfQoqLwoKZnVuY3Rpb24gbm9kZUlkRm9yKG9iaikgewogIHJldHVybiBgJHsgb2JqLm5hbWVzcGFjZSB9OiR7IG9iai5hcHAgfUAkeyBvYmoudmVyc2lvbiB9YDsKfQoKZnVuY3Rpb24gZnJvbUlkKG9iaikgewogIHJldHVybiBgJHsgb2JqLmZyb21OYW1lc3BhY2UgfTokeyBvYmouZnJvbUFwcCB9QCR7IG9iai5mcm9tVmVyc2lvbiB9YDsKfQoKZnVuY3Rpb24gdG9JZChvYmopIHsKICByZXR1cm4gYCR7IG9iai50b05hbWVzcGFjZSB9OiR7IG9iai50b0FwcCB9QCR7IG9iai50b1ZlcnNpb24gfWA7Cn0KCmFzeW5jIGZ1bmN0aW9uIGxvYWREYXRhKHN0b3JlKSB7CiAgY29uc3QgZGF0YSA9IGF3YWl0IHN0b3JlLmRpc3BhdGNoKCdyYW5jaGVyL3JlcXVlc3QnLCB7IHVybDogJy92MS1tZXRyaWNzL21lc2hzdW1tYXJ5JyB9KTsKCiAgY29uc3Qga25vd24gPSB7fTsKCiAgZGF0YS5ub2RlcyA9IGRhdGEubm9kZXMuZmlsdGVyKCh4KSA9PiAhIXguYXBwICYmICEheC5uYW1lc3BhY2UpOwogIGRhdGEubm9kZXMuZm9yRWFjaCgoeCkgPT4gewogICAgeC5pZCA9IG5vZGVJZEZvcih4KTsKICAgIGtub3duW3guaWRdID0gdHJ1ZTsKICB9KTsKCiAgZGF0YS5lZGdlcyA9IGRhdGEuZWRnZXMuZmlsdGVyKCh4KSA9PiBrbm93bltmcm9tSWQoeCldICYmIGtub3duW3RvSWQoeCldKTsKCiAgcmV0dXJuIGRhdGE7Cn0KCmZ1bmN0aW9uIHJvdW5kM0RpZ2l0cyhudW0pIHsKICBpZiAoICFudW0gKSB7CiAgICByZXR1cm4gMDsKICB9CgogIGlmICggbnVtID4gMTAwICkgewogICAgcmV0dXJuIE1hdGgucm91bmQobnVtKTsKICB9IGVsc2UgaWYgKCBudW0gPiAxMCApIHsKICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIDEwKSAvIDEwOwogIH0gZWxzZSB7CiAgICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAxMDApIC8gMTAwOwogIH0KfQoKZXhwb3J0IGRlZmF1bHQgewoKICAvKiAoCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGxvYWRpbmc6IHRydWUsCiAgICAgIC4uLnJhbmRvbURhdGEoKSwKICAgIH07CiAgfSwKICAqLwoKICBhc3luYyBhc3luY0RhdGEoeyBzdG9yZSB9KSB7CiAgICBjb25zdCBkYXRhID0gYXdhaXQgbG9hZERhdGEoc3RvcmUpOwoKICAgIHJldHVybiBkYXRhOwogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIG5hbWVzcGFjZXMoKSB7CiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzWyduYW1lc3BhY2VzJ10oKTsKICAgIH0sCgogICAgZGlzcGxheU5vZGVzKCkgewogICAgICBjb25zb2xlLmxvZygnZ2V0IGRpc3BsYXlOb2RlcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGUKICAgICAgY29uc3QgbmFtZXNwYWNlcyA9IHRoaXMubmFtZXNwYWNlczsKCiAgICAgIGNvbnN0IG91dCA9IHRoaXMubm9kZXMuZmlsdGVyKCh4KSA9PiB7CiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZXNbeC5uYW1lc3BhY2VdOwogICAgICB9KTsKCiAgICAgIHJldHVybiBvdXQ7CiAgICB9LAoKICAgIGRpc3BsYXlFZGdlcygpIHsKICAgICAgY29uc29sZS5sb2coJ2dldCBkaXNwbGF5RWRnZXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlCiAgICAgIGNvbnN0IG5hbWVzcGFjZXMgPSB0aGlzLm5hbWVzcGFjZXM7CgogICAgICBjb25zdCBvdXQgPSB0aGlzLmVkZ2VzLmZpbHRlcigoeCkgPT4gewogICAgICAgIGNvbnN0IG5zMSA9IHguZnJvbU5hbWVzcGFjZTsKICAgICAgICBjb25zdCBuczIgPSB4LnRvTmFtZXNwYWNlOwoKICAgICAgICByZXR1cm4gbmFtZXNwYWNlc1tuczFdICYmIG5hbWVzcGFjZXNbbnMyXTsKICAgICAgfSk7CgogICAgICByZXR1cm4gb3V0OwogICAgfSwKICB9LAoKICB3YXRjaDogewogICAgLy8gTm9kZXMgaXNuJ3Qgd2F0Y2hlZCwgYnV0IGdldHMgdXBkYXRlZCBhdCB0aGUgc2FtZSB0aW1lLi4uCiAgICBub2RlcygpIHsKICAgICAgY29uc29sZS5sb2coJ25vZGVzIHVwZGF0ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlCiAgICAgIHRoaXMudXBkYXRlR3JhcGgoKTsKICAgICAgdGhpcy5yZW5kZXJHcmFwaCgpOwogICAgfSwKCiAgICBuYW1lc3BhY2VzKCkgewogICAgICBjb25zb2xlLmxvZygnbmFtZXNwYWNlcyB1cGRhdGVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQogICAgICB0aGlzLnVwZGF0ZUdyYXBoKCk7CiAgICAgIHRoaXMucmVuZGVyR3JhcGgoKTsKICAgIH0sCgogICAgZWRnZXMoKSB7CiAgICAgIGNvbnNvbGUubG9nKCdlZGdlcyB1cGRhdGVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQogICAgICB0aGlzLnVwZGF0ZUdyYXBoKCk7CiAgICAgIHRoaXMucmVuZGVyR3JhcGgoKTsKICAgIH0sCiAgfSwKCiAgYXN5bmMgbW91bnRlZCgpIHsKICAgIGNvbnNvbGUubG9nKCdNb3VudGVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQogICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKCgpID0+IHsKICAgICAgY29uc29sZS5sb2coJ1RpbWVyJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQogICAgICB0aGlzLnJlZnJlc2hEYXRhKCk7CiAgICB9LCBJTlRFUlZBTCk7CgogICAgYXdhaXQgdGhpcy5pbml0R3JhcGgoKTsKICAgIHRoaXMudXBkYXRlR3JhcGgoKTsKICAgIHRoaXMucmVuZGVyR3JhcGgoKTsKCiAgICB3aW5kb3cubSA9IHRoaXM7CiAgfSwKCiAgYmVmb3JlRGVzdHJveSgpIHsKICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7CiAgfSwKCiAgbWV0aG9kczogewogICAgYXN5bmMgcmVmcmVzaERhdGEoKSB7CiAgICAgIGNvbnNvbGUubG9nKCdSZWZyZXNoaW5nLi4uJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQogICAgICBjb25zdCBuZXUgPSBhd2FpdCBsb2FkRGF0YSh0aGlzLiRzdG9yZSk7CgogICAgICB0aGlzLm5vZGVzID0gbmV1Lm5vZGVzOwogICAgICB0aGlzLmVkZ2VzID0gbmV1LmVkZ2VzOwogICAgICBjb25zb2xlLmxvZygnUmVmcmVzaGVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQogICAgfSwKCiAgICBhc3luYyBpbml0R3JhcGgoKSB7CiAgICAgIGNvbnN0IGQzID0gYXdhaXQgaW1wb3J0KCdkMycpOwogICAgICBjb25zdCBkYWdyZUQzID0gYXdhaXQgaW1wb3J0KCdkYWdyZS1kMycpOwoKICAgICAgY29uc3QgZyA9IG5ldyBkYWdyZUQzLmdyYXBobGliLkdyYXBoKHsgY29tcG91bmQ6IHRydWUgfSk7CgogICAgICBnLnNldEdyYXBoKHsKICAgICAgICBtYXJnaW54OiAwLAogICAgICAgIG1hcmdpbnk6IDAsCiAgICAgICAgcmFua2RpcjogJ0xSJywKICAgICAgICBhbGlnbjogICAnVUwnLAogICAgICAgIHJhbmtlcjogICdsb25nZXN0LXBhdGgnLCAvLyAndGlnaHQtdHJlZScsCiAgICAgIH0pOwoKICAgICAgZy5zZXREZWZhdWx0RWRnZUxhYmVsKCgpID0+IHsKICAgICAgICByZXR1cm4ge307CiAgICAgIH0pOwoKICAgICAgLy8gQ3JlYXRlIHRoZSByZW5kZXJlcgogICAgICBjb25zdCByZW5kZXIgPSBuZXcgZGFncmVEMy5yZW5kZXIoKTsKCiAgICAgIC8vIEFkZCBvdXIgY3VzdG9tIGFycm93CiAgICAgIHJlbmRlci5hcnJvd3MoKS5zbWFsbGVyID0gZnVuY3Rpb24gbm9ybWFsKHBhcmVudCwgaWQsIGVkZ2UsIHR5cGUpIHsKICAgICAgICBjb25zdCBtYXJrZXIgPSBwYXJlbnQuYXBwZW5kKCdtYXJrZXInKQogICAgICAgICAgLmF0dHIoJ2lkJywgaWQpCiAgICAgICAgICAuYXR0cigndmlld0JveCcsICcwIDAgMTIgMTInKQogICAgICAgICAgLmF0dHIoJ3JlZlgnLCA2KQogICAgICAgICAgLmF0dHIoJ3JlZlknLCA2KQogICAgICAgICAgLmF0dHIoJ21hcmtlclVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJykKICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDEyKQogICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDEyKQogICAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJyk7CiAgICAgICAgY29uc3QgcGF0aCA9IG1hcmtlci5hcHBlbmQoJ3BhdGgnKQogICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Fycm93aGVhZCcpCiAgICAgICAgICAuYXR0cignZCcsICdNIDYgMCBMIDAgNiBMIDYgMTIgTCAxMiA2IHonKQogICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAxKQogICAgICAgICAgLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JywgJzEsMCcpOwoKICAgICAgICBkYWdyZUQzLnV0aWwuYXBwbHlTdHlsZShwYXRoLCBlZGdlW2AkeyB0eXBlIH1TdHlsZWBdKTsKICAgICAgfTsKCiAgICAgIC8vIFNldCB1cCBhbiBTVkcgZ3JvdXAgc28gdGhhdCB3ZSBjYW4gdHJhbnNsYXRlIHRoZSBmaW5hbCBncmFwaC4KICAgICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0KHRoaXMuJHJlZnMubWVzaCk7CiAgICAgIGNvbnN0IGdyb3VwID0gc3ZnLmFwcGVuZCgnZycpOwoKICAgICAgY29uc3Qgem9vbSA9IGQzLnpvb20oKS5vbignem9vbScsICgpID0+IHsKICAgICAgICBpZiAoIGQzLmV2ZW50LnNvdXJjZUV2ZW50ICkgewogICAgICAgICAgdGhpcy5sYXN0Wm9vbSA9IGQzLmV2ZW50LnRyYW5zZm9ybTsKICAgICAgICB9CiAgICAgICAgZ3JvdXAuYXR0cigndHJhbnNmb3JtJywgZDMuZXZlbnQudHJhbnNmb3JtKTsKICAgICAgfSk7CgogICAgICBzdmcuY2FsbCh6b29tKTsKCiAgICAgIHRoaXMuZDMgPSBkMzsKICAgICAgdGhpcy5kYWdyZUQzID0gZGFncmVEMzsKICAgICAgdGhpcy5ncmFwaCA9IGc7CiAgICAgIHRoaXMucmVuZGVyID0gcmVuZGVyOwogICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7CiAgICAgIHRoaXMuem9vbSA9IHpvb207CiAgICB9LAoKICAgIHVwZGF0ZUdyYXBoKCkgewogICAgICAvLyBAVE9ETyBkaWZmIG5vZGVzL2VkZ2VzLCByZW1vdmUgdW5leHBlY3RlZCBhbmQgYWRkIG1pc3Npbmcgb25lcwogICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcuLi4nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlCgogICAgICBjb25zdCBlID0gZXNjYXBlSHRtbDsKICAgICAgY29uc3QgZyA9IHRoaXMuZ3JhcGg7CgogICAgICBjb25zdCBzZWVuTmFtZXNwYWNlcyA9IHt9OwoKICAgICAgZm9yICggY29uc3Qgbm9kZSBvZiB0aGlzLmRpc3BsYXlOb2RlcyApIHsKICAgICAgICBjb25zdCBuc0lkID0gZW5zdXJlTmFtZXNwYWNlKG5vZGUubmFtZXNwYWNlKTsKICAgICAgICBjb25zdCBpZCA9IG5vZGVJZEZvcihub2RlKTsKCiAgICAgICAgbm9kZS5sYWJlbCA9IGAkeyBub2RlLmFwcCB9QCR7IG5vZGUudmVyc2lvbiB9YDsKCiAgICAgICAgbGV0IHA5OSA9IG5vZGUuc3RhdHMucDk5bXM7CiAgICAgICAgbGV0IHVuaXQgPSAnbXMnOwoKICAgICAgICBpZiAoIHA5OSA+IDEwMDAgKSB7CiAgICAgICAgICBwOTkgLz0gMTAwMDsKICAgICAgICAgIHVuaXQgPSAncyc7CiAgICAgICAgfQoKICAgICAgICBjb25zdCBodG1sID0gYAogICAgICAgICAgPGRpdiBjbGFzcz0idmVyc2lvbiI+CiAgICAgICAgICAgIDxoND4keyBlKG5vZGUuYXBwKSB9QCR7IGUobm9kZS52ZXJzaW9uKSB9PC9oND4KICAgICAgICAgICAgPGRpdiBjbGFzcz0icm93Ij4KICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb2wgc3Bhbi00IHNyIj4KICAgICAgICAgICAgICAgIDxzcGFuPiR7IHJvdW5kM0RpZ2l0cyhub2RlLnN0YXRzLnN1Y2Nlc3NSYXRlICogMTAwKSB9PC9zcGFuPjxzcGFuIGNsYXNzPSJ1bml0Ij4lPC9zcGFuPgogICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNvbCBzcGFuLTQgcnBzIj4KICAgICAgICAgICAgICAgIDxzcGFuPiR7IHJvdW5kM0RpZ2l0cyhub2RlLnN0YXRzLnJwcykgfTwvc3Bhbj4KICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb2wgc3Bhbi00IHA5OSI+CiAgICAgICAgICAgICAgICA8c3Bhbj4keyByb3VuZDNEaWdpdHMocDk5KSB9PC9zcGFuPjxzcGFuIGNsYXNzPSJ1bml0Ij4keyB1bml0IH08L3NwYW4+CiAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgPC9kaXY+CiAgICAgICAgYDsKCiAgICAgICAgZy5zZXROb2RlKGlkLCB7CiAgICAgICAgICBsYWJlbFR5cGU6ICdodG1sJywKICAgICAgICAgIGxhYmVsOiAgICAgaHRtbCwKICAgICAgICAgIHdpZHRoOiAgICAgMTU4LAogICAgICAgICAgaGVpZ2h0OiAgICA4MCwKICAgICAgICAgIHJ4OiAgICAgICAgUkFESVVTLAogICAgICAgICAgcnk6ICAgICAgICBSQURJVVMsCiAgICAgICAgfSk7CiAgICAgICAgZy5zZXRQYXJlbnQoaWQsIG5zSWQpOwogICAgICB9CgogICAgICBjb25zdCBycHNlcyA9IHRoaXMuZGlzcGxheUVkZ2VzLm1hcCgoeCkgPT4geC5zdGF0cy5ycHMpOwogICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi5ycHNlcyk7CiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnJwc2VzKTsKCiAgICAgIGZvciAoIGNvbnN0IGVkZ2Ugb2YgdGhpcy5kaXNwbGF5RWRnZXMgKSB7CiAgICAgICAgZW5zdXJlTmFtZXNwYWNlKGVkZ2UuZnJvbU5hbWVzcGFjZSk7CiAgICAgICAgZW5zdXJlTmFtZXNwYWNlKGVkZ2UudG9OYW1lc3BhY2UpOwogICAgICAgIGNvbnN0IHdlaWdodCA9IE1hdGguZmxvb3IoNCAqIChlZGdlLnN0YXRzLnJwcyAtIG1pbikgLyAobWF4IC0gbWluKSkgKyAxOwoKICAgICAgICBnLnNldEVkZ2UoZnJvbUlkKGVkZ2UpLCB0b0lkKGVkZ2UpLCB7CiAgICAgICAgICBhcnJvd2hlYWQ6ICAgICAgJ3NtYWxsZXInLAogICAgICAgICAgYXJyb3doZWFkQ2xhc3M6ICdhcnJvd2hlYWQnLAogICAgICAgICAgY2xhc3M6ICAgICAgICAgIGB3ZWlnaHQkeyB3ZWlnaHQgfWAsCiAgICAgICAgICBjdXJ2ZTogICAgICAgICAgdGhpcy5kMy5jdXJ2ZUJhc2lzLAogICAgICAgICAgd2VpZ2h0LAogICAgICAgIH0pOwogICAgICB9CgogICAgICBmdW5jdGlvbiBlbnN1cmVOYW1lc3BhY2UobmFtZSkgewogICAgICAgIGNvbnN0IGlkID0gYG5zOiR7IG5hbWUgfWA7CgogICAgICAgIGlmICggIXNlZW5OYW1lc3BhY2VzW25hbWVdICkgewogICAgICAgICAgc2Vlbk5hbWVzcGFjZXNbbmFtZV0gPSB0cnVlOwogICAgICAgICAgZy5zZXROb2RlKGlkLCB7CiAgICAgICAgICAgIGxhYmVsOiAgICAgICAgICAgYE5hbWVzcGFjZTogJHsgbmFtZSB9YCwKICAgICAgICAgICAgY2x1c3RlckxhYmVsUG9zOiAndG9wJywKICAgICAgICAgICAgcng6ICAgICAgICAgICAgICBSQURJVVMsCiAgICAgICAgICAgIHJ5OiAgICAgICAgICAgICAgUkFESVVTCiAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIHJldHVybiBpZDsKICAgICAgfQogICAgfSwKCiAgICByZW5kZXJHcmFwaCgpIHsKICAgICAgY29uc29sZS5sb2coJ1JlbmRlcmluZy4uLicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGUKCiAgICAgIGNvbnN0IGQzID0gdGhpcy5kMzsKICAgICAgY29uc3Qgc3ZnID0gdGhpcy5kMy5zZWxlY3QodGhpcy4kcmVmcy5tZXNoKTsKICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLmdyb3VwOwogICAgICBjb25zdCBnID0gdGhpcy5ncmFwaDsKICAgICAgY29uc3QgcmVuZGVyID0gdGhpcy5yZW5kZXI7CiAgICAgIGNvbnN0IHpvb20gPSB0aGlzLnpvb207CgogICAgICBzdmcuY2FsbCh6b29tLnRyYW5zZm9ybSwgZDMuem9vbUlkZW50aXR5LnRyYW5zbGF0ZSgwLCAwKS5zY2FsZSgxKSk7CgogICAgICAvLyBSdW4gdGhlIHJlbmRlcmVyLiBUaGlzIGlzIHdoYXQgZHJhd3MgdGhlIGZpbmFsIGdyYXBoLgogICAgICByZW5kZXIoZ3JvdXAsIGcpOwoKICAgICAgY29uc3QgZ3JhcGhXaWR0aCA9IGcuZ3JhcGgoKS53aWR0aDsKICAgICAgY29uc3QgZ3JhcGhIZWlnaHQgPSBnLmdyYXBoKCkuaGVpZ2h0OwogICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KHN2Zy5zdHlsZSgnd2lkdGgnKS5yZXBsYWNlKC9weC8sICcnKSk7CiAgICAgIGNvbnN0IGhlaWdodCA9IHBhcnNlSW50KHN2Zy5zdHlsZSgnaGVpZ2h0JykucmVwbGFjZSgvcHgvLCAnJykpOwogICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKHdpZHRoIC8gZ3JhcGhXaWR0aCwgaGVpZ2h0IC8gZ3JhcGhIZWlnaHQpOwogICAgICBjb25zdCBkWCA9ICh3aWR0aCAvIDIpIC0gKChncmFwaFdpZHRoICogc2NhbGUpIC8gMik7CiAgICAgIGNvbnN0IGRZID0gKGhlaWdodCAvIDIpIC0gKChncmFwaEhlaWdodCAqIHNjYWxlKSAvIDIpOwoKICAgICAgY29uc29sZS5sb2coJ3JlbmRlcicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGUKICAgICAgaWYgKCB0aGlzLmxhc3Rab29tICkgewogICAgICAgIHN2Zy5jYWxsKHpvb20udHJhbnNmb3JtLCBkMy56b29tSWRlbnRpdHkudHJhbnNsYXRlKHRoaXMubGFzdFpvb20ueCwgdGhpcy5sYXN0Wm9vbS55KS5zY2FsZSh0aGlzLmxhc3Rab29tLmspKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBzdmcuY2FsbCh6b29tLnRyYW5zZm9ybSwgZDMuem9vbUlkZW50aXR5LnRyYW5zbGF0ZShkWCwgZFkpLnNjYWxlKHNjYWxlKSk7CiAgICAgIH0KCiAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlOwogICAgfSwKCiAgICBjbGlja2VkKGV2ZW50KSB7CiAgICAgIGNvbnN0IHBhdGggPSBldmVudC50YXJnZXQuY2xvc2VzdCgnLmVkZ2VQYXRoJyk7CgogICAgICBjb25zb2xlLmxvZyhwYXRoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlCiAgICB9CiAgfSwKfTsK"},{"version":3,"sources":["mesh.vue"],"names":[],"mappings":";AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA","file":"mesh.vue","sourceRoot":"node_modules/@rancher/shell/pages/rio","sourcesContent":["<script>\nimport { escapeHtml } from '@shell/utils/string';\n\nconst RADIUS = 5;\n\nconst INTERVAL = 10000;\n\n/*\nfunction randomStats() {\n  return {\n    'p50ms':       Math.random(),\n    'p90ms':       Math.random() * 2,\n    'p99ms':       Math.random() * 5,\n    'rps':         Math.random() * 100,\n    'successRate': Math.random(),\n  };\n}\n\nfunction randomItem(ary) {\n  const idx = Math.floor(Math.random() * ary.length);\n\n  return ary[idx];\n}\n\nfunction randomData() {\n  const nodes = [];\n  const edges = [];\n\n  ['foo', 'bar', 'baz', 'bat', 'qux'].forEach((name) => {\n    nodes.push({\n      'namespace': 'default',\n      'app':       name,\n      'version':   'v1',\n      'stats':     randomStats(),\n    });\n  });\n\n  ['a', 'b', 'c', 'd', 'e'].forEach((name) => {\n    nodes.push({\n      'namespace': 'another',\n      'app':       name,\n      'version':   'v1',\n      'stats':     randomStats(),\n    });\n  });\n\n  for ( let i = 0 ; i < 10 ; i++ ) {\n    const from = randomItem(nodes);\n    const crossNs = Math.random() < 0.2;\n    const toChoices = nodes.filter((x) => {\n      if ( x === from ) {\n        return false;\n      }\n\n      if ( crossNs ) {\n        return x.namespace !== from.namespace;\n      } else {\n        return x.namespace === from.namespace;\n      }\n    });\n    const to = randomItem(toChoices);\n\n    edges.push({\n      fromNamespace: from.namespace,\n      fromApp:       from.app,\n      fromVersion:   from.version,\n      toNamespace:   to.namespace,\n      toApp:         to.app,\n      toVersion:     to.version,\n      stats:         randomStats(),\n    });\n  }\n\n  return {\n    nodes,\n    edges\n  };\n}\n*/\n\nfunction nodeIdFor(obj) {\n  return `${ obj.namespace }:${ obj.app }@${ obj.version }`;\n}\n\nfunction fromId(obj) {\n  return `${ obj.fromNamespace }:${ obj.fromApp }@${ obj.fromVersion }`;\n}\n\nfunction toId(obj) {\n  return `${ obj.toNamespace }:${ obj.toApp }@${ obj.toVersion }`;\n}\n\nasync function loadData(store) {\n  const data = await store.dispatch('rancher/request', { url: '/v1-metrics/meshsummary' });\n\n  const known = {};\n\n  data.nodes = data.nodes.filter((x) => !!x.app && !!x.namespace);\n  data.nodes.forEach((x) => {\n    x.id = nodeIdFor(x);\n    known[x.id] = true;\n  });\n\n  data.edges = data.edges.filter((x) => known[fromId(x)] && known[toId(x)]);\n\n  return data;\n}\n\nfunction round3Digits(num) {\n  if ( !num ) {\n    return 0;\n  }\n\n  if ( num > 100 ) {\n    return Math.round(num);\n  } else if ( num > 10 ) {\n    return Math.round(num * 10) / 10;\n  } else {\n    return Math.round(num * 100) / 100;\n  }\n}\n\nexport default {\n\n  /* (\n  data() {\n    return {\n      loading: true,\n      ...randomData(),\n    };\n  },\n  */\n\n  async asyncData({ store }) {\n    const data = await loadData(store);\n\n    return data;\n  },\n  computed: {\n    namespaces() {\n      return this.$store.getters['namespaces']();\n    },\n\n    displayNodes() {\n      console.log('get displayNodes'); // eslint-disable-line no-console\n      const namespaces = this.namespaces;\n\n      const out = this.nodes.filter((x) => {\n        return namespaces[x.namespace];\n      });\n\n      return out;\n    },\n\n    displayEdges() {\n      console.log('get displayEdges'); // eslint-disable-line no-console\n      const namespaces = this.namespaces;\n\n      const out = this.edges.filter((x) => {\n        const ns1 = x.fromNamespace;\n        const ns2 = x.toNamespace;\n\n        return namespaces[ns1] && namespaces[ns2];\n      });\n\n      return out;\n    },\n  },\n\n  watch: {\n    // Nodes isn't watched, but gets updated at the same time...\n    nodes() {\n      console.log('nodes updated'); // eslint-disable-line no-console\n      this.updateGraph();\n      this.renderGraph();\n    },\n\n    namespaces() {\n      console.log('namespaces updated'); // eslint-disable-line no-console\n      this.updateGraph();\n      this.renderGraph();\n    },\n\n    edges() {\n      console.log('edges updated'); // eslint-disable-line no-console\n      this.updateGraph();\n      this.renderGraph();\n    },\n  },\n\n  async mounted() {\n    console.log('Mounted'); // eslint-disable-line no-console\n    this.timer = setInterval(() => {\n      console.log('Timer'); // eslint-disable-line no-console\n      this.refreshData();\n    }, INTERVAL);\n\n    await this.initGraph();\n    this.updateGraph();\n    this.renderGraph();\n\n    window.m = this;\n  },\n\n  beforeDestroy() {\n    clearInterval(this.timer);\n  },\n\n  methods: {\n    async refreshData() {\n      console.log('Refreshing...'); // eslint-disable-line no-console\n      const neu = await loadData(this.$store);\n\n      this.nodes = neu.nodes;\n      this.edges = neu.edges;\n      console.log('Refreshed'); // eslint-disable-line no-console\n    },\n\n    async initGraph() {\n      const d3 = await import('d3');\n      const dagreD3 = await import('dagre-d3');\n\n      const g = new dagreD3.graphlib.Graph({ compound: true });\n\n      g.setGraph({\n        marginx: 0,\n        marginy: 0,\n        rankdir: 'LR',\n        align:   'UL',\n        ranker:  'longest-path', // 'tight-tree',\n      });\n\n      g.setDefaultEdgeLabel(() => {\n        return {};\n      });\n\n      // Create the renderer\n      const render = new dagreD3.render();\n\n      // Add our custom arrow\n      render.arrows().smaller = function normal(parent, id, edge, type) {\n        const marker = parent.append('marker')\n          .attr('id', id)\n          .attr('viewBox', '0 0 12 12')\n          .attr('refX', 6)\n          .attr('refY', 6)\n          .attr('markerUnits', 'userSpaceOnUse')\n          .attr('markerWidth', 12)\n          .attr('markerHeight', 12)\n          .attr('orient', 'auto');\n        const path = marker.append('path')\n          .attr('class', 'arrowhead')\n          .attr('d', 'M 6 0 L 0 6 L 6 12 L 12 6 z')\n          .style('stroke-width', 1)\n          .style('stroke-dasharray', '1,0');\n\n        dagreD3.util.applyStyle(path, edge[`${ type }Style`]);\n      };\n\n      // Set up an SVG group so that we can translate the final graph.\n      const svg = d3.select(this.$refs.mesh);\n      const group = svg.append('g');\n\n      const zoom = d3.zoom().on('zoom', () => {\n        if ( d3.event.sourceEvent ) {\n          this.lastZoom = d3.event.transform;\n        }\n        group.attr('transform', d3.event.transform);\n      });\n\n      svg.call(zoom);\n\n      this.d3 = d3;\n      this.dagreD3 = dagreD3;\n      this.graph = g;\n      this.render = render;\n      this.group = group;\n      this.zoom = zoom;\n    },\n\n    updateGraph() {\n      // @TODO diff nodes/edges, remove unexpected and add missing ones\n      console.log('Updating...'); // eslint-disable-line no-console\n\n      const e = escapeHtml;\n      const g = this.graph;\n\n      const seenNamespaces = {};\n\n      for ( const node of this.displayNodes ) {\n        const nsId = ensureNamespace(node.namespace);\n        const id = nodeIdFor(node);\n\n        node.label = `${ node.app }@${ node.version }`;\n\n        let p99 = node.stats.p99ms;\n        let unit = 'ms';\n\n        if ( p99 > 1000 ) {\n          p99 /= 1000;\n          unit = 's';\n        }\n\n        const html = `\n          <div class=\"version\">\n            <h4>${ e(node.app) }@${ e(node.version) }</h4>\n            <div class=\"row\">\n              <div class=\"col span-4 sr\">\n                <span>${ round3Digits(node.stats.successRate * 100) }</span><span class=\"unit\">%</span>\n              </div>\n              <div class=\"col span-4 rps\">\n                <span>${ round3Digits(node.stats.rps) }</span>\n              </div>\n              <div class=\"col span-4 p99\">\n                <span>${ round3Digits(p99) }</span><span class=\"unit\">${ unit }</span>\n              </div>\n            </div>\n          </div>\n        `;\n\n        g.setNode(id, {\n          labelType: 'html',\n          label:     html,\n          width:     158,\n          height:    80,\n          rx:        RADIUS,\n          ry:        RADIUS,\n        });\n        g.setParent(id, nsId);\n      }\n\n      const rpses = this.displayEdges.map((x) => x.stats.rps);\n      const min = Math.min(...rpses);\n      const max = Math.max(...rpses);\n\n      for ( const edge of this.displayEdges ) {\n        ensureNamespace(edge.fromNamespace);\n        ensureNamespace(edge.toNamespace);\n        const weight = Math.floor(4 * (edge.stats.rps - min) / (max - min)) + 1;\n\n        g.setEdge(fromId(edge), toId(edge), {\n          arrowhead:      'smaller',\n          arrowheadClass: 'arrowhead',\n          class:          `weight${ weight }`,\n          curve:          this.d3.curveBasis,\n          weight,\n        });\n      }\n\n      function ensureNamespace(name) {\n        const id = `ns:${ name }`;\n\n        if ( !seenNamespaces[name] ) {\n          seenNamespaces[name] = true;\n          g.setNode(id, {\n            label:           `Namespace: ${ name }`,\n            clusterLabelPos: 'top',\n            rx:              RADIUS,\n            ry:              RADIUS\n          });\n        }\n\n        return id;\n      }\n    },\n\n    renderGraph() {\n      console.log('Rendering...'); // eslint-disable-line no-console\n\n      const d3 = this.d3;\n      const svg = this.d3.select(this.$refs.mesh);\n      const group = this.group;\n      const g = this.graph;\n      const render = this.render;\n      const zoom = this.zoom;\n\n      svg.call(zoom.transform, d3.zoomIdentity.translate(0, 0).scale(1));\n\n      // Run the renderer. This is what draws the final graph.\n      render(group, g);\n\n      const graphWidth = g.graph().width;\n      const graphHeight = g.graph().height;\n      const width = parseInt(svg.style('width').replace(/px/, ''));\n      const height = parseInt(svg.style('height').replace(/px/, ''));\n      const scale = Math.min(width / graphWidth, height / graphHeight);\n      const dX = (width / 2) - ((graphWidth * scale) / 2);\n      const dY = (height / 2) - ((graphHeight * scale) / 2);\n\n      console.log('render'); // eslint-disable-line no-console\n      if ( this.lastZoom ) {\n        svg.call(zoom.transform, d3.zoomIdentity.translate(this.lastZoom.x, this.lastZoom.y).scale(this.lastZoom.k));\n      } else {\n        svg.call(zoom.transform, d3.zoomIdentity.translate(dX, dY).scale(scale));\n      }\n\n      this.loading = false;\n    },\n\n    clicked(event) {\n      const path = event.target.closest('.edgePath');\n\n      console.log(path); // eslint-disable-line no-console\n    }\n  },\n};\n</script>\n<template>\n  <div class=\"mesh\">\n    <header>\n      <h1>App Mesh</h1>\n    </header>\n\n    <svg\n      id=\"mesh\"\n      ref=\"mesh\"\n      @click=\"clicked\"\n    />\n  </div>\n</template>\n\n<style lang=\"scss\">\n  #mesh {\n    width: 100%;\n    height: calc(100vh - 165px);\n\n    .version {\n      width: 158px;\n      height: 80px;\n      color: #b6b6c2;\n      text-align: center;\n\n      .row {\n        margin: 0;\n      }\n\n      H4 {\n        color: #b6b6c2;\n        display: block;\n        border-bottom: 1px solid #555;\n        text-align: left;\n        padding-bottom: 5px;\n        margin-bottom: 5px;\n      }\n\n      .sr, .rps, .p99 {\n        font-size: 20px;\n\n        .unit {\n          font-size: 12px;\n        }\n      }\n\n      .sr:before, .rps:before, .p99:before {\n        color: white;\n        font-weight: bold;\n        font-size: 15px;\n        display: block;\n      }\n\n      .sr:before {\n        content: 'SR';\n      }\n\n      .rps:before {\n        content: 'RPS';\n      }\n\n      .p99:before {\n        content: '99%';\n      }\n\n    }\n\n    .clusters .label text {\n      fill: #b6b6c2;\n      font-weight: bold;\n    }\n\n    .clusters RECT {\n      fill: #222;\n      stroke: #555;\n    }\n\n    .arrowhead {\n      fill: #6c6c76;\n    }\n\n    .node RECT {\n      fill: #111;\n      stroke: #555;\n    }\n\n    PATH {\n      stroke: #6c6c76;\n    }\n\n    .edgePath {\n      cursor: pointer;\n    }\n\n    .weight1 { stroke-width: 2px; }\n    .weight2 { stroke-width: 3px; }\n    .weight3 { stroke-width: 4px; }\n    .weight4 { stroke-width: 5px; }\n    .weight5 { stroke-width: 6px; }\n  }\n</style>\n"]}]}